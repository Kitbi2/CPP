# C++11

## 一、列表初始化

### 1-1：{}初始化

```cpp
/* 对于变量 */
int i = 0;
int j = {0};
int p{0};

/* 对于结构体 */
struct Person
{
    int x;
    int y;
};
Person p = {1,2};
Person p{1,2};

/* 数组 */
int array[] = {1,2,3,4,5};
int array[] {1,2,3,4,5};

/* 对于类 */
class Date
{
    
};

Date d1(2023,11,25);
Date d1 = {23,11,25};//这里走的是类型转化，相通过{23,11,25}去构造一个类处理，然后赋值给左值
Date d1{2023,11,25};

/* 对于new出来的类进行初始化 */
class Date
{
    
};

Date * p = new Date[3]{{2022,32,32},{2022,32,32},{2022,32,32}};

```

### 1-2：std::initializer_list

1.针对于初始化列表的数据类型

```cpp
/* 在使用列表初始化的时候去构造类，你也提供了initializer_list参数的构造函数，就会调用这个构造函数 */

std::initializer_list l1 = {1,2,3,4,5};
auto l2 = {1,2,3,4,5};
class Date2
{
public:
    Date2(int a,int b,int c = 6)
    { cout << "Date2(int a,int b,int c)" << endl; }

    Date2(initializer_list<int> ilit)
    { cout << "Date2(initializer_list<int> ilit)" << endl; }
};
void test2(void)
{
    Date2 D1 = {1,2,3};
    Date2 D2 = {1,2,3,4,5};


}
```

2.vector的列表 初始化的构造，和map的列表初始化

```cpp
vector (initializer_list<value_type> il,
       const allocator_type& alloc = allocator_type());

/* 这俩者是不同的，
	vector是走了initializer_list的构造函数，
	而Data是一个类型转化*/
vector<int>  v1 = {1,2,3,4,5};

Date d1{2023,11,25};


```

## 二、声明

### 2-1：auto的使用

### 2-2：decltype

1.decltype会根据你提供值，推导出对应的类型

```cpp
// decltype的一些使用使用场景
template<class T1, class T2>
void F(T1 t1, T2 t2)
{
decltype(t1 * t2) ret;
cout << typeid(ret).name() << endl;
}
int main()
{
    const int x = 1;
    double y = 2.2;
    decltype(x * y) ret; // ret的类型是double
    decltype(&x) p;      // p的类型是int*
    cout << typeid(ret).name() << endl;
    cout << typeid(p).name() << endl;
    
    vector<decltype(x * y)> v1;//此时这里的模板就只能是decltype而不能是auto
    F(1, 'a');
    return 0;
}

```

## 三、容器的变化

1.arrary、forward_list、unordered_map、unordered_set

2.新的构造函数

3.移动构造和移动赋值

4.右引用的引入

5.其他的接口(cbegin，cend)

## 四、右值引用和移动语义

### 4-1：左值的定义和右值的定义

左值是一个表示数据的表达式(如变量名或解引用的指针)，**我们可以获取它的地址+可以对它赋值**，左值可以出现赋值符号的左边，右值不能出现在赋值符号左边。定义时const修饰符后的左 值，不能给他赋值，但是可以取它的地址。左值引用就是给左值的引用，给左值取别名。

```cpp
/* 这些都是左值的范畴 */
int a;
int * p;
int & p1;
const int p;
```

右值也是一个表示数据的表达式，如：字面常量、表达式返回值，函数返回值(这个不能是左值引 用返回)等等，右值可以出现在赋值符号的右边，但是不能出现出现在赋值符号的左边，**右值不能取地址**。右值引用就是对右值的引用，给右值取别名。

```cpp
// 以下几个都是常见的右值
10;
x + y;
fmin(x, y);
”abcde“;
```



### 4-2：左值引用和右值引用

1.左值引用就是我们常用的引用了，没什么好所的

2.右值引用

```cpp
类型 && + 引用名字;

/* 我们可以通过右值引用去引用右值，继而改变右值 */
double && pp = 1.0;


```

1. 左值引用只能引用左值，不能引用右值。 2. 但是const左值引用既可引用左值，也可引用右值。
2. 右值引用只能右值，不能引用左值。 2. 但是右值引用可以move以后的左值。

### 4-3：右边值引用的场景、移动构造、移动赋值

#### 4-3-1：左值引用的价值是什么

1.传入参数的时候可以不进行拷贝

2.返回值堆上或者静态区的数据的时候

#### 4-3-2：右值引用

1.返回局部变量的时候右值引用就需要引入了

```cpp

/* 如果这里使用string& ，
	那么里面ret是一个局部变量，
	那么ret这块内存就是非法的了。 */
string to_string(int val)
{
    string ret;
	while(val)
	{
		int tmp = val % 10;
        val /= 10;
        ret.push_back(tmp + '0');
	}
	return ret;
}
string(const string & str)
{
    cout << " string(const yjt::string & str) " << endl;
    yjt::string tmp(str._str);
    swap(_str,tmp._str);
    swap(_capacity,tmp._capacity);
    swap(_size,tmp._size);
}
yjt::string&  operator=(const yjt::string & str)
{
    cout << "operator=(const string & str)" << endl;
    string tmp(str._str);
    swap(_str,tmp._str);
    swap(_capacity,tmp._capacity);
    swap(_size,tmp._size);    
    return *this;
}
int main()
{
    /* 在使用传统左值的情况下，
    	这里会调用俩次深拷贝，
    	分别是to_string返回值的拷贝构造
    	和赋值重载里面tmp变量的构造 ，
    	这样很浪费空间 */
    string val;
    val = to_string(10086);
    return 0;
}
```

![image-20231228185446105](pir\image-20231228185446105.png)

2.引入将亡值：自定义类型要被释放的内存，我们可以通过右值引用去引用将亡值

```cpp
string&& to_string(int val)
{
    string ret;
	while(val)
	{
		int tmp = val % 10;
        val /= 10;
        ret.push_back(tmp + '0');
	}
	return ret;
}
yjt::string&  operator=(const yjt::string & str)  // 
{
    cout << "operator=(const string & str)" << endl;
    string tmp(str._str);
    swap(_str,tmp._str);
    swap(_capacity,tmp._capacity);
    swap(_size,tmp._size);    
    return *this;
}
yjt::string&  operator=( yjt::string && str)
{
    swap(_str,str._str);
    swap(_capacity,str._capacity);
    swap(_size,str._size);
    delete str._str;
    return *this;
}
string( string && str)
{
    
    
    cout << " string(const yjt::string && str)" << endl;
    /* 为什么左值的深拷贝或者赋值不能这样写？
    	左值引用一般是针对于消亡值，
    	那么销亡值你直接swap，
    	后面要用到怎么办？ */
    swap(_str,str._str);
    delete str._str;

}

int main()
{
	/* 在提供了右值引用之后就发生改变,
		在构造to_string的返回值的时候是通过右值引用去构造，
		也就说直接把to_string里面的ret里面的内容做交换就好了，
		赋值重载也是同一个道理的。这样就省去这俩词深拷贝构造 */
    string val1;
    string val2("aaaaa");
    val1 = to_string(10086); 
    val1 = val2;
    return 0;
}
```

![image-20231228185852454](pir\image-20231228185852454.png)



3.右值引用在STL里面的使用

这个问题我们可以使用move解决 

#### 4-3-3：万能引用

1.语法

```cpp
template<typename T>
//如果T为左值就是左值引用，如果为右值就是右值引用
void Perword(T && p)
{
    
    Fun(p);
}
```



```cpp
void Fun(int & pa) {cout << "Fun(int & pa)" << endl;}
void Fun(const int & pa) {cout << "Fun(const int & pa)" << endl;}
void Fun(int &&  pa) { cout << "Fun(int &&  pa)  " << endl;}

template<typename T>
void Perword(T && p)
{
    Fun(p);
}

void test5(void)
{
    int a = 60;
    /* 此时这俩代码都会输出Fun(int & pa)，
    	因为即使给到右值，T被推成int && 类型，
    	但是int && p是一个左值，所以会调用Fun(int & pa)*/
    Perword(a);
    Perword(60);
}
```

2.为了解决上面的问题，我们就需要完美转发

```cpp
/**
 * 说明:万能引用的完美转发
 * forward<T>(p)
 * 
 * 
*/
void Fun(int & pa) {cout << "Fun(int & pa)" << endl;}
void Fun(const int & pa) {cout << "Fun(const int & pa)" << endl;}
void Fun(int &&  pa) { cout << "Fun(int &&  pa)  " << endl;}

template<typename T>
void Perword(T && p)
{
    //这里就会保留万能引用本来的类型
    Fun(std::forward<T>(p));
}

void test5(void)
{
    int a = 60;
    Perword(a);
    Perword(60);
}
```

## 五、类的新功能

### 5-1：默认成员函数

1.构造函数 2. 析构函数 3. 拷贝构造函数 4. 拷贝赋值重载 5. 取地址重载 6. const 取地址重载

#### 5-1-1：在c++1中会提供移动构造函数

1.定义类的时候没有实现析构函数、拷贝构造、赋值重载中三个函数，就会提供默认的移动构造函数、

2.默认的移动构造函数，对于内置类型，会按字节进行拷贝，内置类型需要看这个成员是否友移动构造，如果有就调用移动构造，如果没有就调用拷贝构造。

#### 5-1-2：移动赋值

1.定义类的时候没有实现析构函数、拷贝构造、赋值重载中三个函数，就会提供默认的移动赋值函数

2.默认的移动构造函数，对于内置类型，会按字节进行拷贝，内置类型需要看这个成员是否友移动赋值函数，如果有就调用移动赋值函数，如果没有就调用拷贝赋值。

```cpp
{

};
class tmp2
{
public:
    tmp2(void)
    {
        cout << "tmp2(void)" << endl;
    }
    tmp2(const tmp2 & t)
    {
        cout << "tmp2(tmp2 & t)" << endl;
    }
    tmp2(tmp2 && t)
    {
        cout << "tmp2(tmp2 && t)" << endl;
    }
};
tmp2 _test6(void)
{
    tmp2 ret;

    return ret;
}
void test6(void)
{
    tmp2 t1;
    tmp2 t2 = _test6();

}
```



### 5-2：强制生成默认函数的关键字default

### 5-3：禁止生成默认函数的关键字delete

### 5-4：继承和多态中的final与override关键字

## 六、可变参数模板

```cpp
template<class ...Args>
void ShowList(Args... args)
{
    	
    cout << sizeof...(args) << endl;
}

int main()
{
    
    return 0;
}
```

1.如果使用和如何展开

```cpp
/**
 * 不定模板参数
 * 
 * 
*/
template<class T>
void _ShowList2(T& t)
{
    cout << t << endl;
}
template<class T,class ...Args>
void _ShowList2(T& t,Args ...args)
{
    cout << t << " ";
    _ShowList(args...);
}
template <class T>
void PrintArg(T t)
{
 cout << t << " ";
}

template <class ...Args>
void _ShowList1(Args... args)
{
 int arr[] = { (PrintArg(args), 0)... };
 cout << endl;
}

template<class ...Args>
void ShowList(Args ...args)
{
    cout << sizeof...(args) << endl;	
    // _ShowList2(args...);
    _ShowList1(args...);
}
void test7(void)
{
    ShowList(1,2,3);
    ShowList(1,2,'x');
    ShowList(1,2,3.0);
    
}
```

2.STL中的使用

```cpp
template <class... Args>
  void emplace_back (Args&&... args);

string test(void)
{
    string ret;
    return ret;
}
int main()
{
    vector<string> v1;
    string ret = "gfasfas"
    v1.push_back(ret);
    
    /* 这里先是构造string，如何用移动构造去给到node */
    v1.emplace_back("fadsfasdfa");
     /* 这里直接移动构造node */
    v1.emplace_back(test());
}

```

关于emplace_back和push_back的效率的区别



```c
  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


new _Tp(std::forward<_Args>(__args)...));//这里是一个逗号表达式进行对模板参数的展开，也就是说，传入进来的可变参数，会一个一个的去给到forward函数进行调用，并且根据都好参入到_Tp中。
```



## 七、lambda表达式

### 7-1：语法

```cpp
[捕获抓列表](参数)->返回类型{执行语句};
auto f1 = [](int a,int b){ cout << a << end; return 1;};
int a = 0;
f1(a,a);
```

#### 7-1-1：使用场景

1.我们要只用sort对自定类型继续排序的时候，无法直接比较大小，我们需要写一个仿函数，但是仿函数又太重了，我们就只需要几个语句，所以此时labdam就来了

```cpp
struct Goods
{
    string _name;
    int _price;
    int _evaluate;
};
void test8(void)
{
    vector<Goods> v = {{"苹果",1,4},{"香蕉",4,5},{"葡萄",7,1}};
    /* 因为模板的作用，
    	所以我们可以通过labdam表达式生成对应的类型，
    	继而调用labdam。 */
    sort(v.begin(),v.end(),[](Goods t1,Goods t2){ return t1._evaluate > t2._evaluate; });

    for(auto & ch : v)
    {
        cout << ch._name << endl;
        cout << ch._price << endl;
        cout << ch._evaluate << endl;
    }
    /* 如果需要按照其他规则进行排序也是改一下后面的表达式即可 */
    //价格
    sort(v.begin(),v.end(),[](Goods t1,Goods t2){ return t1._price > t2._price; });
	//名字
    sort(v.begin(),v.end(),[](Goods t1,Goods t2){ return t1._name > t2._name; })

}
```

### 7-2：底层

1.lambda的底层是类，然后通过括号重载(operator()(T 1, T2) )，这里的T1，T2就是又lambda类型决定的，返回值就是又我们写入的返回值决定的（可以不写返回值，编译器回自动推导）。

### 7-3：捕捉列表

#### 7-3-1：捕捉变量

```cpp
[=] [val]  
[&] [&val]
```

1.普通的捕捉变量

```cpp
int a = 2,b = 3,c = 4;
/* 对变量进行普通的捕捉 [=] [val]  */
auto f1 = [a,b,c](){cout << a << " " << b << " " << c << endl;};
f1();

/* 变量的捕捉是具有常性的，
	无法直接进行修改，
	我们需要假如mutable进行修饰，
    才能修改。 */
auto f1 = [a,b]()mutable{
    int tmp = a;
    a = b;
    b = tmp;
};
f1();
cout << a << " " << b << endl;



/* [=] 捕捉，把域内的全部参数都捕捉了 */
int a = 2,b = 3,c = 4;

auto f1 = [=]()mutable{
    int tmp = a;
    a = b;
    b = tmp;
    cout << a << " " << b << " "<< c << endl;
};
f1();
cout << a << " " << b << endl;
/* 参数的捕捉只是形参！ */
```

#### 7-3-2：捕捉引用

```cpp
//捕捉引用
int a = 2,b = 3,c = 4;
auto f1 = [&]()mutable{
    int tmp = a;
    a = b;
    b = tmp;
    cout << a << " " << b << " "<< c << endl;
};
f1();
cout << a << " " << b << endl;

//捕捉引用
int a = 2,b = 3,c = 4;
auto f1 = [&a,&b]()mutable{
    int tmp = a;
    a = b;
    b = tmp;
    cout << a << " " << b << " " << endl;
};
f1();
cout << a << " " << b << endl;
```

#### 7-3-3：类内捕捉

1.类内捕捉无法直接捕捉成员变量的要么通过this进行捕捉，本质是因为捕捉列表只能捕捉父域的变量

```c++
struct Goods
{
    void tmp(void)
    {
        auto f1 = [this](){
            cout << _name << endl;
            cout << _price << endl;
            cout << _evaluate << endl;
        };
        f1();
    }
    string _name;
    int _price;
    int _evaluate;
};

struct Goods
{
    void tmp(void)
    {
        /* 这里可以不是因为捕捉到了成员变量，
        	是因为捕捉到了this指针*/
        auto f1 = [=](){
            cout << _name << endl;
            cout << _price << endl;
            cout << _evaluate << endl;
        };
        f1();
    }
    string _name;
    int _price;
    int _evaluate;
};
```



## 八、包装器

### 8-1：为何要有包装器？

1.先假定一个场景，map里面我们一个存调用接口的名字，另外一个存储调用函数。对于整个函数调用我们有很多种实现，为了有一个统一的类型，就有了包装器

2.一般用于包装函数、仿函数、lambda表达式

3.语法

```cpp
function<返回值(参数)>;
```

4.类似于typedef的操作，不过比typedef好用很多，包装器直接规定了你要调用函数的类型，准确的说应该是你要调用函数的形式

```
function(void(void));//这个规定的就是一个参数为void，返回值为void的函数调用，
```



#### 8-1-1：包装函数

```cpp
void add(int a,int b)
{
    cout << "the result1 is " <<  a + b << endl;
}
//要求函数里面的参数和返回值和包装器的一样
function<void(int,int)>  f1 = add;
```

#### 8-1-2：lambda表达式

```cpp

//要求lambda表达式的参数和返回值和包装器的一样
function<void(int,int)>  f3 = [](int a,int b){cout << "the result5 is " <<  a + b << endl;};
 
```

#### 8-1-3：包装仿函数

```cpp
//要求括号重载的函数的返回值和包装器的一样

class Add
{
public:
    void operator()(int a,int b)
    {
        cout << "the result2 is " <<  a + b << endl;

    }
};
function<void(int,int)>  f2 = Add();
f2(1,2);
 
```

#### 8-1-4：包装类内函数

1.静态函数

```cpp
class Add_all
{
public:

    static void test1(int a,int b)
    {
        cout << "the result3 is " <<  a + b << endl;
    }
   
};

/* 要求类内的静态函数的返回值和参数一样 */
function<void(int,int)>  f4 = &Add_all::test1;
f4(1,2);
```

2.非静态函数

```cpp
class Add_all
{
public:


    void test2(int a,int b)
    {
        cout << "the result4 is " <<  a + b << endl;
    }    
};

/* 方式1 */
function<void(Add_all,int,int)>  f5 = &Add_all::test2;
f5(Add_all(),1,2);

/* 方式2 */
Add_all a1;
function<void(Add_all*,int,int)>  f6 = &Add_all::test2;
f6(&a1,1,2);
```





```cpp
void add(int a,int b)
{
    cout << "the result1 is " <<  a + b << endl;
}
class Add
{
public:
    void operator()(int a,int b)
    {
        cout << "the result2 is " <<  a + b << endl;

    }
};


map<string,function<void(int,int)> > m1 = 
    {{"函数调用",add},
     {"仿函数",Add()},
     {"lambda",[](int a,int b){cout << "the result5 is " <<  a + b << endl;}}};

cout << endl;
m1["函数调用"](1,2);
m1["仿函数"](1,2);
m1["lambda"](1,2);
```

### 8-2：bind

1.用于给函数参数进行绑定

```cpp
#include <functional>
int Plus(int a, int b)
{
    return a + b;
}
class Sub
{
public:
    int sub(int a, int b)
    {
    return a - b;
    }
};
int main()
{
    //表示绑定函数plus 参数分别由调用 func1 的第一，二个参数指定
    std::function<int(int, int)> func1 = std::bind(Plus, placeholders::_1, placeholders::_2);
    //auto func1 = std::bind(Plus, placeholders::_1, placeholders::_2);
    //func2的类型为 function<void(int, int, int)> 与func1类型一样
    //表示绑定函数 plus 的第一，二为： 1， 2
    auto  func2 = std::bind(Plus, 1, 2);   
    cout << func1(1, 2) << endl;
    cout << func2() << endl;
    Sub s;

    std::function<int(int, int)> func3 = std::bind(&Sub::sub, s, 
    placeholders::_1, placeholders::_2);

    std::function<int(int, int)> func4 = std::bind(&Sub::sub, s, 
    placeholders::_2, placeholders::_1);
    cout << func3(1, 2) << endl; 
    cout << func4(1, 2) << endl;
    return 0;
}

```

2.没有绑定参数的情况

```cpp
int Plus(int a, int b)
{
    return a + b;
}
std::function<int(int, int)> func1 = std::bind(Plus, placeholders::_1, placeholders::_2);
//这就表示，你要调用func1的时候需要给到俩个参数
```

3.绑定参数的情况

```cpp
int Plus(int a, int b)
{
    return a + b;
}
std::function<int(void)> func1 = std::bind(Plus, 1, 2);

//你可以直接调用fun1()，要知道的是你bind只会，就和参数绑定上了，不能在传入参数了。
```



