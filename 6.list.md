# list

## 一、使用

### 1-1：构造函数

| 函数                                                     | 说明                                |
| -------------------------------------------------------- | ----------------------------------- |
| list (size_type n, const value_type& val = value_type()) | 构造的list中包含n个值为val的元素    |
| list()                                                   | 构造空的list                        |
| list (const list& x)                                     | 拷贝构造函数                        |
| list (InputIterator first, InputIterator last)           | 用[first, last)区间中的元素构造list |

### 1-2：迭代器

| 函数声明       | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| begin +  end   | 返回第一个元素的迭代器+返回最后一个元素下一个位置的迭代器    |
| rbegin +  rend | 返回第一个元素的reverse_iterator,即end位置，返回最后一个元素下一个位置的 reverse_iterator,即begin位置 |

### 1-3：增删改查

| 函数       | 说明                                    |
| ---------- | --------------------------------------- |
| front      | 返回list的第一个节点中值的引用          |
| back       | 返回list的最后一个节点中值的引用        |
| push_front | 在list首元素前插入值为val的元素         |
| pop_front  | 删除list中第一个元素                    |
| push_back  | 在list尾部插入值为val的元素             |
| pop_back   | 删除list中最后一个元素                  |
| insert     | 在list position 位置中插入值为val的元素 |
| erase      | 删除list position位置的元素             |
| swap       | 交换两个list中的元素                    |
| clear      | 清空list中的有效元素                    |



### 1-4：迭代器的性质、

迭代器的性质：单向 ++，双向++ --，随机 ++ -- / + -

也就是链表不能用算法库里面的sort，所以list提供了一个sort

```
    list<int> l1;
    l1.sort();
```

## 二、底层实现

### 2-1：一些基本的功能就是双向链表的增删改查

没什么好说的

### 2-2：迭代器的实现

#### 2-2-1：比较一下vector迭代器的实现

```c++
    template<class T>
    class vector
    {
    public:
        //迭代器和const迭代器，
   
        typedef T* iterator;
        typedef const T* const_iterator;

    private:
        iterator _start = nullptr;
        iterator _finish = nullptr;
        iterator _endofstroage = nullptr;
    };    
/* vector的迭代器我们是直接采用了原生指针，因为内存空间是连续的缘故，所以直接++或者--迭代器我们可以直接移动到下一个数据的内存 */     
```

#### 2-2-2：抛出问题list的迭代器使能像vector一样使用原生指针

1.如果说list的指针也是像vector一样使用原生指针，那么堆迭代器的++是无法到达下一个数据的，因为list的数据存储是非连续的，是链式结构的。

```c++
//所以我们要实现的++ 和--应该是让迭代器指向下一个结点/上一个节点
p = p->_next;
p = p->_prev;

/* 基于上面的需求，我们可以定义一个类，然后对该类的运算符进行重载继而实现我们迭代器  */

/* 迭代器 */
    template<class T,class Ref,class Ptr>
    struct _list_iterator
    {
        typedef list_node<T> Node;
        typedef _list_iterator self;

        _list_iterator(Node * node)
        { _node = node; }
        
        /* 进行++的时候让成员node指向下一个节点 */
        self& operator++(void)
        { 
            _node = _node->_next;
            return *this;
        }
         /* 解引用的时候使用返回node指向的内容 */
        Ref operator*(void)
        {
            return _node->_val;
        }
        bool operator!=(const self&  t1)
        {
            if(_node == t1._node)
                return false;
            return true;
        }
        /* 保存要进行操作的节点指针 */
        Node * _node;
        
    };
//类内对迭代器的定义如下
typedef _list_iterator<T,T& ,T*> iterator;
iterator<int> l1; /* 推导成入下 */ _list_iterator<int,int &,int*> l1;
那么迭代器struct的三个模板参数就会被实例化为 T = int,Ref = int&,Ptr=int* 
//常量迭代器
typedef _list_iterator<T,const T&,const T*> const_iterator;
const_iterator<int> l1; /* 推导成入下 */ _list_iterator<int,const int &,const int*> l1;
那么迭代器struct的三个模板参数就会被实例化为 T = int,Ref = const int&,Ptr=const int* 

```

**1.迭代器是否需要深拷贝和析构**

不需要，迭代器里面的node只是一个指针，即使析构了，也会去销毁指向的内存，以为不是由迭代器管理的

**2.经典的list里面是类的问题**

1.拷贝构造的情况

2.赋值的情况

#### 2-2-3：一个通用的Print

```
	template<typename Container>
	void print_container(const Container& con)
	{
		typename Container::const_iterator it = con.begin();
		while (it != con.end())
		{
			cout << *it << " ";
			++it;
		}
		cout << endl;
	}
```


