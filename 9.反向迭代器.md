# 反向迭代器

## 一、何为迭代器

1.为容器提供一个统一的访问接口，屏蔽了底层细节

## 二、反向迭代器的实现

### 2-1：参考一下正向迭代器

```c++
    
	
	/* 实现正向的时候我们是抽象成一个类，然后把节点指针封装为私有成员变量，
    	因为不能直接对原生指针进行++，--的操作，所以我们要对其进行重载 */
    template<class T,class Ref,class Ptr>
    struct _list_iterator
    {
        typedef list_node<T> Node;
        typedef _list_iterator self;

        _list_iterator(Node * node)
        { _node = node; }
        self& operator++(void)
        { 
            _node = _node->_next;
            return *this;
        }
        self& operator--(void)
        { 
            _node = _node->_prev;
            return *this;
        }
        Ref operator*(void)
        {
            return _node->_val;
        }
        bool operator!=(const self&  t1)
        {
            if(_node == t1._node)
                return false;
            return true;
        }
        Node * _node;
        
    };
```

**我们可不可以像普通迭代器一样实现反向迭代器**：

当然可以，一样的封装就好了，但是这一点也不c++
**其他方法实现反向迭代器**：

结合我们学习的容器适配器的思想，普通的迭代器的操作是不是和一般迭代器操作有类似的地方

```c++
class ReverseIterator
{

public:
    typedef ReverseIterator<Ierator,Ref,Ptr> Self;

    ReverseIterator(Ierator tmp)
    :_it(tmp)
    { }
    Self& operator++(void)
    {
        --_it;
    }
    Self& operator--(void)
    {
        ++_it;
    }

    Ref operator*(void)
    {
        return *_it;

    }

    bool operator!=(const ReverseIterator& targt)
    {
        return _it != targt._it;
    }
private:
    Ierator _it;
};


//通过end返回一个正向迭代器，去
构造反向迭代器reverse_iterator rbegin(void)
{
    return reverse_iterator(--end());
}
reverse_iterator rend(void)
{
    return reverse_iterator(end());
} 
//list<int>会把T推导为int
yjt::list<int>::reverse_iterator rit = l1.rbegin();

typedef _list_iterator<T,T& ,T*> iterator;

//
typedef ReverseIterator<iterator,T&,T*>     reverse_iterator;

```



1.关于返回值的常性，内置类型和自定义类型的区别

2.库中即使了对称，并且解决了越界的问题