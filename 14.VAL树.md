# VAL树

## 一、基本概念

1.还是搜索树，只不过要求每颗子树之间的左右子树高度差要求为了。

2.那么为什么不能是相等：emmm，你为什么不能学习24个小时？



## 二、如何控制每棵树的左右子树高度差为1

### 2-0：引入概念-高度因子

1.高度因子：用于描述左右子树的高度差

<img src="pir\tree1.png" alt="tree1" style="zoom:25%;" />

如图：更节点的高度因子便是1

### 2-1：新增节点的时候会发生什么情况

<img src="pir\tree2.png" alt="tree2" style="zoom:25%;" />

如图（tree2）：非黑色的节点便是我们新的节点，此时新增的节点5，会影响到节点3的高度引子，但是没有影响到节点3的高度，那么节点1的高度因子也不会被改变

<img src="pir\tree3.png" alt="tree3" style="zoom:50%;" />

如图（tree3）：非黑色的节点便是我们新的节点，此时新增的节点5，会影响到节点3的高度引子，同时影响到节点3的高度，那么节点1的高度因子也会被改变

#### **总结**：

1.如果新增的节点没有影响到树的高度，那么祖先的高度因子不会被影响到，反之则会造成影响

2.我们假定新增再左节点高度因子为++，右节点为--

3.如果插入之后的父亲的平衡因子为0不用调整，为-1/1的时候子树高度变了需要上报进行平衡因子的调整，为-2/2的时候就需要进行调整了

### 2-2：调整策略

1.当我们新增完节点之后，祖先节点出现高度因子为2/-2的时候就需要进行调整

#### 2-2-1：右右的情况、左单旋

1.插入节点造成有祖先节点的高度因子为2，并且插入的是祖先的右子树，同时插入的地方也是祖先右子树的右子树



![tree4](pir\tree4.png)

2.左单转：以为高度因子为2的祖先的右子树为轴心进行向左的旋转，祖先的右子树的左子树变为祖先的右子树，祖先的右子树作为新的祖先，原来的祖先变为右子树的左子树

3.调整完祖先和祖先的右子树的高度因子都为0，并且不需要继续向上调整（原先祖先高度为1的时候不需要调整，现在变成0了，就更加不需要了。

```c++
template<class K,class V>
void VALTree<K,V>::Letable(Node * perant)
{
    Node * cur = perant->right;
    Node * ppnode = perant->perant;


    perant->right = cur->left;
    if(cur->left != nullptr)
        cur->left->perant = perant;


    cur->left = perant;
    perant->perant = cur;

    //在perant作为树的根节点的情况下，cur变成了根。cur->perant直接为空。
    if(perant == _root)
    {
        _root = cur;
        cur->perant = nullptr;
    }
    else
    {
        if(perant == ppnode->left)
        {
            ppnode->left = cur;
        }
        else if(perant == ppnode->right)
        {
            ppnode->right = cur;
        }
        cur->perant = ppnode;        
    }

    perant->_bf = 0;
    cur->_bf = 0;
}
```



#### 2-2-2：左左的情况、右单旋

1.插入的节点导致祖先的高度因子为2，并且在祖先的左子树，并且在祖先的左子树的左子树上

![tree5](pir\tree5.png)

2.右单旋：祖先的左子树作为新的祖先，祖先的左子树的右子树作为祖先的左子树，祖先作为祖先的右子树的左子树,高度因子和左单旋是一样的

```c++
	Node * cur = perant->left;
    Node * ppNode = perant->perant;

	//祖先的左子树的右子树作为祖先的左子树，
    perant->left = cur->right;
    if(perant->left != nullptr)
        perant->left->perant = perant;

	//祖先作为祖先的右子树的左子树
    cur->right = perant;
    perant->perant = cur; 


	//祖先的左子树作为新的祖先
    if(perant == _root)
    {
        _root = cur;
        cur->perant = nullptr;
    }
    else
    {
        if(ppNode->left == perant)
            ppNode->left = cur;
        else
            ppNode->right = cur;

        cur->perant = ppNode;
    }
    perant->_bf = 0;
    cur->_bf = 0;
```



#### 2-2-3：右左、先右单旋再左单旋

1.插入节点造成有祖先节点的高度因子为2，并且插入的是祖先的右子树，同时插入的地方也是祖先右子树的右子树，这种情况是新增的节点作为祖先节点的左子树的右子树

2.情况一：选择完原来祖先的高度因子变为-1，主席的右子树的高度因子变为0，祖先右子树的左子树变为0

![tree6](pir\tree6.png)

3.情况二：选择完原来祖先的高度因子变为0，主席的右子树的高度因子变为1，祖先右子树的左子树变为0



![tree8](pir\tree8.png)

2.先左单旋再右单旋：先对祖先的左子树的右子树进行右单旋，然后在对祖先的左子树的右子树进行左单选。

```c++
template<class K,class V>
void VALTree<K,V>::RLetable(Node * perant)
{
    Node * cur = perant->right;
    Node * cur_le = cur->left;
    int curle_bf = cur_le->_bf;
    Retable(cur);
    Letable(perant);

    if(curle_bf == 0)
    {
        perant->_bf = cur->_bf = cur_le->_bf = 0;
    }
    else if(curle_bf== 1)
    {
        cur_le->_bf = 0;
        perant->_bf = -1;
        cur->_bf = 0;
    }
    else if(curle_bf == -1)
    {
        cur_le->_bf = 0;
        perant->_bf = 0;
        cur->_bf = 1;        
    }
    else
    {
        assert(false);
    }    
}
```



#### 2-2-3： 左右、先左单旋再右单旋

插入节点造成有祖先节点的高度因子为2，并且插入的是祖先的左子树，同时插入的地方也是祖先右子树的右子树

1.情况一：选择完原来祖先的高度因子变为1，祖

先的左子树的高度因子变为0，祖先左子树的右子树变为0

![tree7](pir\tree7.png)



2.情况二：选择完原来祖先的高度因子变为0，主席的左子树的高度因子变为-1，祖先左子树的右子树变为0

![image-20231130152852383](pir\image-20231130152852383.png)

2.情况三：选择完原来祖先的高度因子变为0，主席的左子树的高度因子变为0，祖先左子树的右子树变为0，这种情况是新增的节点作为祖先节点的右子树的左子树

```c++
template<class K,class V>
void VALTree<K,V>::LRetable(Node * perant)
{
    Node * cur = perant->left;
    Node * cur_ri = cur->right;
    int curri_bf = cur_ri->_bf;

    Letable(cur);
    Retable(perant);

    if(curri_bf == 0)
    {
        cur->_bf = 0;
        cur_ri->_bf = 0;
        perant->_bf = 0;
    }
    else if(curri_bf == 1)
    {
        cur->_bf = -1;
        cur_ri->_bf = 0;
        perant->_bf = 0;
    }
    else if(curri_bf == -1)
    {
        perant->_bf = 1;
        cur->_bf = 0;
        cur_ri->_bf = 0;
    }
    else
    {
        assert(false);
    }
}
```



## 三、旋转后为何能保持为搜索二叉树不变

![tree5](pir\tree5.png)

这里进行了左选，把30拿来做parent，无论什么情况，30的结点一定比60的结点小或者大（这里为了满足搜索二叉树的性质，在左边的全部结点一定比根小，在右边的结点一定根大），60可以作为30右子树，因为30本来是60的左子树，证明60一定比30打，而b在60的左边，证明b一定比60小，所以b可以作为60的左子树



