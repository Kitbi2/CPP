# Vecotr

## 一、Vecotr的使用

### 1-1：析构函数

| 函数                                                         | 说明                               |
| ------------------------------------------------------------ | ---------------------------------- |
| vector (const allocator_type& alloc = allocator_type());     | 默认构造函数                       |
| vector (size_type n, const value_type& val = value_type(),                  const allocator_type& alloc = allocator_type()); | 有参构造函数，vector里面填写n个val |
| vector (const vector& x);                                    | 拷贝构造函数                       |
| vector (InputIterator first, InputIterator last);            | 使用迭代器进行初始化               |

### 1-2：遍历Vector

1.下标遍历，vector和string一样，都是可以通过下标访问的方式去遍历

```cpp
    vector<int> num1(12,63);

    //下标访问
    for(int i = 0;i < num1.size();i++)
    {
        cout << num1[i] << " ";
        num1[i] = i;
    }
    cout << endl;
```

2.迭代器

```
 vector<int> num1(12,63);
 
     //迭代器
    std::vector<int>::iterator begin = num1.begin();
    while(begin != num1.end())
    {
        cout << *begin << " ";
        begin++;
    }
    cout << endl;
```

### 1-3：空间

| 函数     | 说明                 |
| -------- | -------------------- |
| size     | 获取有效数据个数     |
| capacity | 获取空间大小         |
| empty    | 是否为空             |
| resize   | 改变vector的size     |
| reserve  | 改变vector的capacity |

```cpp
    vector<int> num1(5,63);

    cout << "有效数据为" << num1.size() << endl;
    cout << "开辟的空间大小为 "<< num1.capacity() << endl;
    
    //resize 
    num1.resize(3);
    cout << "有效数据为" << num1.size() << endl;
    cout << "开辟的空间大小为 "<< num1.capacity() << endl;

    num1.resize(10);
    std::vector<int>::iterator begin = num1.begin();
    while(begin != num1.end())
    {
        cout << *begin << " ";
        begin++;
    }
    cout << endl;
    cout << "有效数据为" << num1.size() << endl;
    cout << "开辟的空间大小为 "<< num1.capacity() << endl;

    //reserve

    num1.reserve(30);
    cout << "有效数据为" << num1.size() << endl;
    cout << "开辟的空间大小为 "<< num1.capacity() << endl;

```

### 1-4：增删查改

| 函数      | 说明                                                     |
| --------- | -------------------------------------------------------- |
| push_back | 在尾部插入数据                                           |
| pop_back  | 在尾部删除数据                                           |
| find      | 查找数据（注意这个是算法模块实现，不是vector的成员接口） |
| insert    | 在某个位置插入数据                                       |
| erase     | 删除某个位置的数据                                       |
| swap      | 交互俩个vector的数据                                     |

```cpp
    vector<int> num1;
    push_back和pop_back
    
    num1.push_back(1);
    num1.push_back(2);
    num1.push_back(3);
    num1.push_back(4);
    num1.push_back(5);
    num1.push_back(6);

    std::vector<int>::iterator begin1 = num1.begin();
    while(begin1 != num1.end())
    {
        cout << *begin1 << " ";
        begin1++;
    }
    cout << endl;
    num1.pop_back();
    num1.pop_back();
    num1.pop_back();
    num1.pop_back();
    num1.pop_back();
    num1.pop_back();
    std::vector<int>::iterator begin2 = num1.begin();
    while(begin2 != num1.end())
    {
        cout << *begin2 << " ";
        begin2++;
    }
    cout << endl;

    insert 和 erase

    num1.insert(num1.begin(),1);
    num1.insert(num1.begin(),2);
    num1.insert(num1.begin(),3);
    num1.insert(num1.begin(),4);
    num1.insert(num1.begin(),5);
    std::vector<int>::iterator begin2 = num1.begin();
    while(begin2 != num1.end())
    {
        cout << *begin2 << " ";
        begin2++;
    }
    cout << endl;

    num1.erase(num1.begin());
    num1.erase(num1.begin());
    num1.erase(num1.begin());
    begin2 = num1.begin();
    while(begin2 != num1.end())
    {
        cout << *begin2 << " ";
        begin2++;
    }
    cout << endl;

```



### 1-3：扩容机制

1.问reserve空间开出来了就可以通过[]去访问吗 

## 二、vecotr的实现

### 2-1：迭代器失效

```c++
template<typename T>
typename::yjt::vector<T>::iterator yjt::vector<T>::insert(iterator it,const T& val)
{
    size_t len = it - _start;
    assert(it >= _start && it <= _finish);
    if(_finish == _endofstroage)
    {
        size_t _capacity = capacity();
        reserve(_capacity == 0? 4:_capacity * 2);        
    }
    /* 在进行扩容之后，it指向的是原本的空间，_start已经指向了一块新的空间，此时我们需要进行迭代器的更新，以防止迭代器失效造成的内存泄漏 */
    //防止迭代器失效
    it = _start + len;
    iterator end = _finish;
    while(end > it)
    {
        *end = *(end - 1);
        --end;
    }
    *it = val;
    _finish++;

    return it;
}
```

### 2-2：扩容的拷贝问题

```c++
template<typename T>
void yjt::vector<T>::reserve(size_t n)
{
    if(n > capacity())
    {
        size_t len = size();
        iterator tmp = new T[n];
        for(size_t i = 0;i < len;i++)
        {
            /* 我们不能直接使用memcpy去进行拷贝，如果使用了memcpy，在T为string类型的情况下就会出现内存泄漏，因为tmp和_start的str指向的是用一块内存，_start会被delete掉。这里采用赋值就个规避，string的赋值会进行深度拷贝 */
            tmp[i] = _start[i];
        }
        delete[] _start;
        _start = tmp;
        _finish = _start + len;
        _endofstroage = _start + n;

    }
}
```

