## 搜索二叉树

### 1-1：概念：

1.右子树比根节点小，左子树比根节点小的二叉树

默认情况下，一颗搜索二叉树是不可以有重复的值 

1.实现基本的插入,查找、删除，and实现递归

```c++
template<class K>
bool BSTree<K>::Insert(K & val)
{
    if(_root == nullptr)
    {
        BSTree_Node<K> * node = NewNode(val);        
        _root = node;
    }
    BSTree_Node<K> * perant = nullptr;
    BSTree_Node<K> * root = _root;
    while(root)
    {
        if(val < root->_val)
        {
            perant = root;
            root = root->left;   
        }
        else if(val > root->_val)
        {
            perant = root;
            root = root->right;
        }
        else
        {
            return false;
        }
    }


    BSTree_Node<K> * node = NewNode(val);

    if(val < perant->_val)
    {
        perant->left = node;
    }
    else if(val > perant->_val)
    {
        perant->right = node;
    }

    return true;
}


template<class K>
bool BSTree<K>::Find(const K& val)
{
    BSTree_Node<K> * cur = _root;
    while(cur)
    {   
        if(val < cur->_val)
        {
            cur = cur->left;
        }
        else if(val > cur->_val)
        {
            cur = cur->right;
        }
        else
        {
            return true;
        }

    }
    return false;
}

template<class K>
bool BSTree<K>::Erase(const K & val)
{
    BSTree_Node<K> * perant = nullptr;
    BSTree_Node<K> * cur = _root;
    while(cur)
    {   
        

        if(val < cur->_val)
        {
            perant = cur;
            cur = cur->left;
        }
        else if(val > cur->_val)
        {
            perant = cur;
            cur = cur->right;
        }
        else
        {
            break;
        }

    }  
    if(cur == nullptr)
        return false;  

    if(cur->left == nullptr)
    {

        if(cur == _root)
        {
            BSTree_Node<K> * tmp = cur;
            _root = _root->right;
            delete  tmp;
        }
        else
        {

        
            
            if(cur == perant->left)
            {
                
                BSTree_Node<K> * tmp = cur;
                perant->left = cur->right;
                delete tmp;
            }
            else if(cur == perant->right)
            {
                
                BSTree_Node<K> * tmp = cur;
                perant->right = cur->right;
                delete tmp;            
            }
        }

    }
    else if(cur->right == nullptr)
    {

        if(cur == _root)
        {
            BSTree_Node<K> * tmp = cur;
            _root = _root->left;
            delete  tmp;
        }
        else
        {

            if(cur == perant->left)
            {
                BSTree_Node<K> * tmp = cur;
                perant->left = cur->left;
                delete tmp;
            }
            else
            {
                BSTree_Node<K> * tmp = cur;
                perant->right = cur->left;
                delete tmp;            
            }
        }

    }
    else
    {

        BSTree_Node<K> * perant_t = cur;
        BSTree_Node<K> * BR = cur->right;
        while(BR->left)
        {
            perant_t = BR;
            BR = BR->left;
        }

        swap(cur->_val,BR->_val);

        if(BR == perant_t->left)
            perant_t->left = BR->right;
        else if(BR == perant_t->right)
            perant_t->right = BR->right; 

        delete BR;       
    }

    return true;
    
}
```

2.实现树的销毁，也就是析构

```c++
template<class K>
void BSTree<K>::Destory(BSTree_Node<K> *& root)
{
    if(root == nullptr)
        return;
    Destory(root->left);
    Destory(root->right);

    delete root;

    root = nullptr;

}
```

3.拷贝构造的实现

```c++
template<class K>
BSTree_Node<K> * BSTree<K>::Copy(BSTree_Node<K> * root)
{
    if(root == nullptr)
        return nullptr;
    
    BSTree_Node<K> * node = NewNode(root->_val);
    node->left = Copy(root->left);
    node->right = Copy(root->right);

    return node;
}
```

4.赋值重载

```c
template<class K>
BSTree<K>& operator=( BSTree<K> bt)
{

    swap(_root,bt._root);
    return *this;
}
```

3.递归实现插入和



### 1-2：时间复杂度的分析

1.不同的搜索二叉树很难保证是O(logN)的时间复制度，所以普通的搜索二叉树是O(n)的时间复杂度

### 1-3：应用场景

1.Key的搜索模型：确定一个值在不在

2.KV模型：每一个关键码key，都有与之对应的值Value，即的键值对。实现一个key  
