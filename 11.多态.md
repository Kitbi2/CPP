# 多态

## 一、多态的概念

### 1-1：基本的概念

1.对于同一个动作，不同的人动作出现的效果是不一样的。

2.比如：同样是高考，有得人上北大，有的人上广科。

## 二、多态的实现和写法

1.虚函数重写，父类的指针/引用去调用虚函数

2.父子类的虚函数，函数名，参数，返回值都相同（可以不同，但是必须 是夫子类的引用或者指针）

3.虚函数便是通过virtual去修饰的函数

```c++
class Person
{
public:
    /* 父类的虚函数 */
    virtual void BuyTicket(void)
    {
        cout << "全价购票" << endl;
    }
};


class Student : public Person
{
public:
    /* 子类继承到父类的虚函数 */
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }    
};

class Child : public Person
{
public:
    /* 子类继承到父类的虚函数 */
    virtual void BuyTicket(void)
    {
        cout << "免费价购票" << endl;
    }    
};



Child c1;
Student s1;

/* 父类的引用去接受子类 */ 
Person & p1 = c1;
/* 父类的引用去接受子类 */ 
Person & p2 = s1;

/* 通过父类的引用度调用子类虚的函数 */
p1.BuyTicket();

/* 通过父类的引用度调用子类的虚函数 */
p2.BuyTicket();

//多态调用就是父类的指针或者引用指向子类，然后通过父类的指针或者引用去调用虚函数
```

###  2-1：虚函数的重写

1.要求虚函数的重写要满足函数名，返回值，参数完全一致

```c++
class Person
{
public:
    /* 父类的虚函数,
    	被注释掉的都是不构成多态条件的*/
    //void BuyTicket(void)
    //int BuyTicket(void)
    //void BuyTicket(int)
    virtual void BuyTicket(void)
    {
        cout << "全价购票" << endl;
    }
};


class Student : public Person
{
public:
    /* 子类继承到父类的虚函数 */
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }    
};

class Child : public Person
{
public:
    /* 子类继承到父类的虚函数 */
    virtual void BuyTicket(void)
    {
        cout << "免费价购票" << endl;
    }    
};
```

### 2-2：重载，重写，隐藏

1.重载是指同一个作用域函数名字相同，函数参数不同

2.重写是函数名，返回值，参数完全一致

3.覆盖是俩个函数在基类和派生类中，函数名一样

```c++
class Person
{
public:
    /* 父类的虚函数,
    	被注释掉的都是不构成多态条件的*/
    //void BuyTicket(void)
    //int BuyTicket(void)
    //void BuyTicket(int)
    virtual void BuyTicket(void)
    {
        cout << "全价购票" << endl;
    }
};


class Student : public Person
{
public:
    /* 子类继承到父类的虚函数 */
    virtual void BuyTicket(void)
    /* 这种是对父类的隐藏 */
    //virtual void BuyTicket(int)
    {
        cout << "半价价购票" << endl;
    }    
};
```

### 2-3：特殊情况

1.返回值是父子类的引用也能构成重写（俩个父，俩个子，或者父子各一个）

```c++
class A
{

};
class B 
{

};

class Person
{
public:
    virtual B& BuyTicket(void)
    {
        cout << "全价购票" << endl;
    }
};


class Student : public Person
{
public:
    virtual A& BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }    
};
```

### 2-4：析构函数的重写

1.直接在父类的函数加virtual修饰就好了

```c++
class Person
{
public:

    virtual void BuyTicket(void)
    {
        cout << "全价购票" << endl;
    }

     ~Person(void)
    {
        cout << "~Person(void)" << endl;
    }
};


class Student : public Person
{
public:
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }    
    virtual ~Student(void)
    {
        cout << "~Student(void)" << endl;
    }
};

//要对虚函数进行重写主要是为了如下情况


/* 如果我们没有对析构函数进行重写的话，
	这个delete调用的析构函数会是Person，
    重写的话就会是Stduent的*/
Person * p1 = new Student;
delete p1;
```



## 三、final、override和虚函数

1.final要修饰函数只能修饰虚函数，此时该函数不能被重写

```c++
class Person
{
public:

    virtual  void BuyTicket (void) final //此时子类中的BuyTicket就无法对齐进行重写
    {
        cout << "全价购票" << endl;
    }

    virtual ~Person(void)
    {
        cout << "~Person(void)" << endl;
    }
};


class Student : public Person
{
public:
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }  

    virtual ~Student(void)
    {
        cout << "~Student(void)" << endl;
    }
};
```

2.override用于检查派生类的虚函数是否被重写  

## 四、抽象类

1.纯虚函数

```c++
//在虚函数声明的后面加个 = 0该函数便是纯虚函数
virtual  void BuyTicket (void) = 0;
```

2.抽象类就包含存续函数的类，抽象类无法实例化出对象，其子类如果没有对其进行重写，也无法实例化出对象

3.一般我们会在子类对纯虚函数进行重写，所以就可以实现子类的实例化

```c++
class Person
{
public:

    virtual  void BuyTicket (void) = 0;

};


class Student : public Person
{
public:
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }  

    virtual ~Student(void)
    {
        cout << "~Student(void)" << endl;
    }
};

Student s1;
s1.BuyTicket();
```

4.抽象类我们就可以给一个父类，然后通过多个子类对齐进行重写，可以实现统一的接口。

## 五、多态的原理

### 5-1：c++会把虚函数存入到虚函数表中去（也就是一个函数指针数组）

```c++
class Person
{
public:

   	
    virtual  void BuyTicket (void) 
    {
        cout << "全价购票" << endl;
    }

};

/*如果你把这个虚函数去掉会发现输出为1，
	加上输出为8，因为有虚函数就有了一个虚函数表指针*/
cout << sizeof(Person) << endl;
```

### 5-2：分析一下父类指针调用虚函数会实现调用子类的虚函数的原因

1.通过父类的引用/指针去指向子类的时候发生了什么事情

```c++
class Person
{
public:
    /* 父类的虚函数*/

    virtual void BuyTicket(void)
    {
        cout << "全价购票" << endl;
    }
};


class Student : public Person
{
public:
    /* 子类继承到父类的虚函数 */
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }    
};


/* 这里会把子类的虚表指针切片给到父类指针/引用，
	因为子类里面只有一张虚函数表，
	如果多态条件不成立，就会去调用父类的重名函数，
	这是因为继承的切片原理*/
Person * p = new Student;
/* 这里此时的p指向了一个子类，，然后通过子类的虚函数表指针去访问虚函数，
	那么接下来就是访问到子类的虚函数 */
p->BuyTicket();
```

3.对象不会把虚表指针进行拷贝，如果拷贝虚表会直接乱套，比如析构函数，还有关于不能保证父类虚表指向父类的虚表

```c++
class Person
{
public:
    /* 父类的虚函数*/

    virtual void BuyTicket(void)
    {
        cout << "全价购票" << endl;
    }
};


class Student : public Person
{
public:
    /* 子类继承到父类的虚函数 */
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    }    
};
Student s;
/* 如果说类赋值也会改变虚表，那么本来要调用Person的虚函数，叫调用Stduent的序号函数 */
Person p = s;
```

4.不同的类会用不同的虚表，相同的类会用一张虚表

## 六、 虚表和虚函数是存储在哪里的

1.虚函数：位于代码段

2.虚表：对于静态区

```c++
int a = 0;
int main(int argc,char * argv[])
{
    Person p;
    int num = 0;
    static int i =0;
    printf("全局地址 %p",&a);
    printf("栈地址 %p",&num);
    printf("静态地址 %p",&a);
    printf("虚表地址 %p",*(int*)&p);
    printf("虚函数地址 %p",&Person::BuyTicket);
}
```

2.虚函数一定会被放入到类的虚函数表中吗？是的，全部的虚函数都会放入虚表中

```c++

class Person
{
public:

    virtual  void BuyTicket (void) 
    {
        cout << "void BuyTicket (void) " << endl;
    }
    virtual  void BuyTicket1(void) 
    {
        cout << "void BuyTicket1 (void) " << endl;
    }
    virtual  void BuyTicket2(void) 
    {
        cout << "void BuyTicket2 (void) " << endl;
    }
    
    virtual  void BuyTicket3(void) 
    {
        cout << "void BuyTicket3 (void) " << endl;
    }
    
};
typedef void(*VF)(void);

void PrintVF(VF a[])
{
    for(int i = 0;i < 3;i++)
    {
        printf("VF function ptr is %p\n",a[i]);
        VF tmp = a[i];
        tmp();
    }
}

//实例化Person
Person p;

/* ((VF*)*(int*)&p)读取p的地址并且强转为int*，然后解引用
	，就访问到头四个字节
	，需就是虚表 
	,因为之前强制为int*解引用会被当成int，所以我们要二度强转为函数指针的指针*/
PrintVF((VF*)(*(int*)&p));


```



## 七、多继承的多态

1.关于多继承对同一个函数进行重写，但是地址不同（）

2.虚表有多少个？：一般来说，继承了多少个父类，就有多少个虚表

```c++
class Person1
{
public:

    virtual  void BuyTicket (void) 
    {
        cout << "void BuyTicket (void) " << endl;
    }
    virtual  void BuyTicket1(void) 
    {
        cout << "void BuyTicket1 (void) " << endl;
    }
    virtual  void BuyTicket2(void) 
    {
        cout << "void BuyTicket2 (void) " << endl;
    }
    
    virtual  void BuyTicket3(void) 
    {
        cout << "void BuyTicket3 (void) " << endl;
    }
    
};
class Person2
{
public:

    virtual  void BuyTicket (void) 
    {
        cout << "void BuyTicket (void) " << endl;
    }
    virtual  void BuyTicket1(void) 
    {
        cout << "void BuyTicket1 (void) " << endl;
    }
    virtual  void BuyTicket2(void) 
    {
        cout << "void BuyTicket2 (void) " << endl;
    }
    
    virtual  void BuyTicket3(void) 
    {
        cout << "void BuyTicket3 (void) " << endl;
    }
    
};

class Student : public Person1 ,public Person2
{
public:
    virtual void BuyTicket(void)
    {
        cout << "半价价购票" << endl;
    } 
    
    /* 这个虚函数会被写入到第一张父类的虚表中去 */
    virtual void BuyTicket8(void)
    {
        cout << "Student void BuyTicket8 (void) " << endl;
    }
    
    virtual ~Student(void)
    {
        cout << "~Student(void)" << endl;
    }
};

typedef void(*VF)(void);

void PrintVF(VF a[])
{
    for(int i = 0;i < 1;i++)
    {
        printf("VF function ptr is %p\n",a[i]);
        VF tmp = a[i];
        tmp();
    }
}

Student s;
Person1 * p1 = &s;
Person2 * p2 = &s;
PrintVF((VF*)(*(int*)p1));
PrintVF((VF*)(*(int*)p2));

printf("虚表1 %p\n",(*(int*)p1));
printf("虚表2 %p\n",(*(int*)p2));


```

 

## 八、菱形继承中的多态

1.包含虚继承的情况下的虚表数量

2.没有虚继承的情况的虚表数量