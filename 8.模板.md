# 模板

## 一、迄今为止学到了模板用法

### 1-1：常量迭代器

```c++
template<class T,class Ref,class Ptr>;


typedef _list_iterator<T,T& ,T*> iterator;
//这里给到const做修饰，就可以实现* 的时候返回常量的引用
typedef _list_iterator<T,const T&,const T*> const_iterator;
```



### 1-2：容器适配器

```c++

template<class T,class Container = list<T>>
    class queue
    {
    public:
        void push(const  T& val)
        {
            Con.push_back(val);
        }
        void pop(void)
        {
            Con.pop_front();
        }
        bool empty(void)
        {
            Con.empty();
        }
        T& front(void)
        {
            Con.front();
        }
        size_t size(void)
        {
            Con.size();
        }
    private:
        Container Con;    
    };
```



### 1-3：仿函数

```c++
    template<class T>
    class less
    {
    public:
        bool operator()(const T& val1,const T& val2)
        {
            // cout << "gg" << endl;
            if(val1 > val2)
                return true;
            return false;
        }
    };


    template<class T>
    class greater
    {
    public:
        bool operator()(const T& val1,const T& val2)
        {
            // cout << "gg" << endl;
            if(val1 < val2)
                return true;
            return false;
        }
    };
    template<class T,class Container = vector<T>,class Compare = yjt::less<T>>
    class Priority_queue
    {
    public:
        void auto_up(int child)
        {
            Compare con;
            int child_t = child;
            int perant_t = (child - 1) /2;
            while(child_t > 0)
            {
                if(con(Con[child_t] , Con[perant_t]))
                // if(Con[child_t] > Con[perant_t])
                {   

                    std:swap(Con[child_t],Con[perant_t]);
                    child_t = perant_t;
                    perant_t = (child_t - 1) /2;

                }
                else
                {
                    break;
                }
            }
        }
        void auto_down(int perant)
        {
            Compare con;
            int perant_t = perant;
            int child_t = perant * 2 + 1;

            while(child_t <(Con.size() ))
            {
                if(child_t + 1 < (Con.size() )&&
                  /*(Con[child_t] < Con[child_t+1])*/
                  con(Con[child_t + 1] , Con[child_t]))
                {
                    child_t += 1;
                }
                if(con(Con[child_t] , Con[perant_t]))

                // if(Con[child_t] > Con[perant_t])
                {
                    std::swap(Con[perant_t],Con[child_t]);
                    perant_t = child_t;
                    child_t = perant_t * 2 + 1;
                    
                }
                else
                {
                    break;
                }
            }
        }

        void Print()
        {
            for(auto ch: Con)
            {
                cout << ch << " ";

            }
            cout << endl;
        }
        void push(const T& val)
        {
            Con.push_back(val);
            auto_up(Con.size() - 1);
        }
        void pop(void)
        {
            std::swap(Con[0],Con[Con.size() - 1]);
            Con.pop_back();
            auto_down(0);
        }
        T& top(void)
        {
            return Con.front();
        }
        bool empty(void)
        {
            return Con.empty();
        }

        void m_swap(Priority_queue & pq1)
        {
            std::swap(*this,pq1);
        }
 
    private:
        Container Con;
    };
```



## 二、非类型模板参数

```c++
/* 这里的N便是一个非类型的模板参数，N为常量，实例化的时候必须用常量去实例化，在c++20之前只能是整形  */
template<class T,size_t N>
    
```

## 三、模板特化

```c++

//1.源模板
template<class T1,class T2>
class Data
{
public:

private:
  T1 _d1;
  T2 _d2;
    
}
//2.全特化 
template<>
class Data<int,int>
{
public:

private:
  T1 _d1;
  T2 _d2;
    
}

//3.篇特化 
template<>
class Data<T,int>
{
public:

private:
  T1 _d1;
  T2 _d2;
    
}

int main()
{

	Date<double,double> d1;
 	Date<int,int> d1;
	Date<double,int> d1;
   
}
```

4.无论是全特化还是偏特化都是不能单独存在的，都是需要有原模板的存在，匹配的时候是根据最何时的进行匹配



  

### 2-1：函数特化

## 四、模板函数的分离  

1.显示实例化，但是这和我们使用模板的初衷，不就违背了

2.声明和定义都写在一个文件里面  





























