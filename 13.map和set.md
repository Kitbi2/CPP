# map和set

1.序列式容器和关联式容器的区别

## 一、set

### 1-1：概念

1.本质上set是一颗搜索树，作用于key模型，也就是插在key是否在书中

2.也不支持修改

### 1-2：基本的使用

#### 1-2-2：insert

```cpp
pair<iterator,bool> insert (const value_type& val);

set<int> s;

s.insert(5);
s.insert(4);
s.insert(1);
s.insert(9);

set<int>::iterator it = s.begin();

while(it != s.end())
{
    cout << * it << endl;
    it++;
}


```

1.关于template <class T1, class T2> struct pair

```cpp
template <class T1, class T2> struct pair
/* 
	pair里面有俩个成员变量，第一个成员变量为frist类型为T1，第二个为second类型为T2
*/
pair<iterator,bool> insert (const value_type& val);


/* insert的返回值是一个pair类，frist的类型是iterator，second类型是bool */


set<int> s;

pait<set<int>::iterator,bool> ret = s.insert(5);

cout << ret.frist << endl;
cout << ret.second << endl;


```

#### 1-2-3：erase和find的配合使用

```cpp
/* 迭代器区删除 */
void erase (iterator position);
/* 指定数值删除 */
size_type erase (const value_type& val);
 
/* 迭代器区间删除 */
void erase (iterator first, iterator last);

/* set中查找元素，没找到返回end() */
iterator find (const value_type& val) const; 



/* 迭代器删除，删除非法迭代器 */

    s.insert(5);
    s.insert(4);
    s.insert(1);

	s.erase(s.find(5));//合法迭代器
    s.erase(s.find(7));//非法迭代器会直接崩溃

    set<int>::iterator it = s.begin();
/* 值删除，删除存在和不存在 */
    s.insert(5);
    s.insert(4);
    s.insert(1);

	s.erase(5);//存在的值
    s.erase(7);//不存在的值，不会崩溃

```

#### 1-2-4：lower_bound和upper_bound

```cpp
iterator lower_bound (const value_type& val) const;
//返回>=val的迭代器
iterator upper_bound (const value_type& val) const;
//返回>val的迭代器


//实例1
s.insert(1);
s.insert(2);
s.insert(3);
s.insert(4);
s.insert(5);
s.insert(6);
s.insert(7);
s.insert(8);

set<int>::iterator low =  s.lower_bound(3);

set<int>::iterator up  = s.upper_bound(7);
while(low != up)
{
    cout << *low << endl;
    low++;
}


//实例2
s.insert(1);
s.insert(2);
s.insert(3);

s.insert(5);
s.insert(6);
s.insert(7);
s.insert(8);

set<int>::iterator low =  s.lower_bound(4);

set<int>::iterator up  = s.upper_bound(7);
while(low != up)
{
    cout << *low << endl;
    low++;
}
```



#### 1-2-5：equal_range

```cpp
pair<iterator,iterator> equal_range (const value_type& val) const;
/* pair的frist是>=val的迭代器 second是>val的迭代器 */

#include <iostream>
#include <set>

int main ()
{
  std::set<int> myset;

  for (int i=1; i<=5; i++) myset.insert(i*10);   // myset: 10 20 30 40 50

  std::pair<std::set<int>::const_iterator,std::set<int>::const_iterator> ret;
  ret = myset.equal_range(30);

  std::cout << "the lower bound points to: " << *ret.first << '\n';
  std::cout << "the upper bound points to: " << *ret.second << '\n';

  return 0;
}
```

## 二、multiset

### 2-1：概念

1.set的变形，允许相同的元素进入到树中

### 2-2：基本的使用

#### 2-2-1：insert

```
iterator insert (const value_type& val);

multiset<int> mset;
mset.insert(1);
mset.insert(1);
mset.insert(2);
mset.insert(2);
mset.insert(3);
mset.insert(4);

multiset<int>::iterator begin = mset.begin();

while(begin != mset.end())
{
    cout << *begin << endl;
    begin++;
}
```

#### 2-2-2：在多个重复元素的情况下，find返回什么？中序遍历的第一个元素

```cpp
/* 迭代器区删除 */
void erase (iterator position);
/* 指定数值删除,返回值为删除的个数 */
size_type erase (const value_type& val);
 
/* 迭代器区间删除 */
void erase (iterator first, iterator last);

multiset<int> mset;
mset.insert(1);
mset.insert(1);
mset.insert(2);
mset.insert(2);
mset.insert(2);
mset.insert(2);
mset.insert(2);
mset.insert(3);
mset.insert(4);


multiset<int>::iterator begin = mset.find(2);

while(begin != mset.end())
{
    cout << *begin << endl;
    begin++;
}
```

#### 2-2-3：equal_range 用于删除多个重复的元素

```cpp
pair<iterator,iterator> equal_range (const value_type& val) const;
iterator find (const value_type& val) const;

multiset<int> mset;
mset.insert(1);
mset.insert(1);
mset.insert(2);
mset.insert(2);
mset.insert(2);
mset.insert(2);
mset.insert(2);
mset.insert(3);
mset.insert(4);


pair<multiset<int>::iterator,multiset<int>::iterator> ret = mset.equal_range(2);

mset.erase(ret.first,ret.second);
multiset<int>::iterator begin = mset.begin();

while(begin != mset.end())
{
    cout << *begin << endl;
    begin++;
}
```

## 三、map

### 3-1：概念

1.map本质上也就是搜索树，只不过用的是key-val模型



### 3-2：基本的使用

#### 3-2-1：关于value_type

```cpp
/* 在map中的value_type是	pair<const key_type,mapped_type>,
	也就是k值不可被改变，但是val可以被改变，那么我们看一下下面的代码 */

map<string,string> m;
/* 这里pair构造出来的类是pair<string,string>,但是insert的value_type是const pair<const key_type,mapped_type> &，
	这里就发生二次构造，通过pair<string,string>("sort","排序")这个类去构造出const pair<const key_type,mapped_type>，
    继而赋值给insert的参数，因为涉及到类型转化，构造出来的类是常量。*/
m.insert(pair<string,string>("sort","排序"));
m.insert(pair<string,string>("insert","插入"));


```

#### 3-2-2：insert和make_pair使用

| single element (1) | `pair<iterator,bool> insert (const value_type& val); `       |
| -----------------: | ------------------------------------------------------------ |
|      with hint (2) | `iterator insert (iterator position, const value_type& val); ` |
|          range (3) | `template <class InputIterator>  void insert (InputIterator first, InputIterator last);` |

1.make_pair

```cpp
template <class T1,class T2>
pair<T1,T2> make_pair (T1 x, T2 y)
{
	return ( pair<T1,T2>(x,y) );
}
```

2.insert和make_pair

```cpp
map<string,string> m;
m.insert(make_pair("sort","排序"));
m.insert(make_pair("insert","插入"));
m.insert(make_pair("left","左边"));
m.insert(make_pair("right","右边"));

auto begin = m.begin();


while(begin != m.end())
{
    cout << (*begin).first << endl;
    begin++;
}
```

#### 3-2-3：支持second修改，但是不支持frist修改是如何实现的

```cpp
/* find的返回值都是迭代器，已经有了就直接返回值迭代器，如果没有就插入了再返回 */
iterator find (const key_type& k);
const_iterator find (const key_type& k) const;

/* 我们解引用得到的就是一个value_type，也就是pair<const key_type,mapped_type>，
	那么返回得到的key值便是不可被修改的*/
```

```cpp
map<string,string> m;

m.insert(make_pair("sort","排序"));
m.insert(make_pair("insert","插入"));
m.insert(make_pair("left","左边"));
m.insert(make_pair("right","右边"));

auto begin = m.begin();


while(begin != m.end())
{
    (*begin).second += 'a';
    cout << "the key: " << (*begin).first <<" the val: " << (*begin).second <<endl;
    begin++;
}
```

#### 3-2-4：关于对[]是干了些什么事情

```cpp
mapped_type& operator[] (const key_type& k)
{
    
	return (*((this->insert(make_pair(k,mapped_type()))).first)).second;
}    

//这一步是插入，把k值的东西插入到对应的数值中去,insert的返回值是pair<iterator,bool>
(this->insert(make_pair(k,mapped_type())))

//.first就是,得到插入元素的迭代器
((this->insert(make_pair(k,mapped_type()))).first)
    
//最后的*(iterator).second也就是得到val 
(*((this->insert(make_pair(k,mapped_type()))).first)).second   
```