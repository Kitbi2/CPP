# 智能指针



## 一、RAII

1.我们把一个资源通过一个类帮我们进行保管。

2.在构造这个类的时候就会对我们的资源进行获取，析构的是就会自动的释放资源

3.这样我们不用显示的去释放资源，而且能保证对象所有的资源在生命周期内有效。

### 1-1：智能指针

1.在C++98,C++11中有提供了这些东西，针对的是类

2.我们经常要new一个对象出来，但是容易忘记释放这种情况，所以说就有了智能指针，你new出来的对象给到智能指针，可以通过在智能指针对其进行操作，智能指针会帮我们自动释放

3.RALL特性

4.像指针一样

5.拷贝问题

## 二、auto_ptr确实是挫

### 2-1：C++98的智能指针 auto_ptr

1.大概的用法如下：模板参数填写的是你的目标指针类型，然后通过构造函数给到一个指针。

```cpp
class Test
{
public:
    Test(void)
    { 
        std::cout << "Test(void)" <<std::endl;
    }
    ~Test(void)
    { 
        std::cout << "~Test(void)" <<std::endl;
    }
};
int main(int argc,char * argv[])
{
	
    /* 模板填 */ 
    std::auto_ptr<Test>  pt(new Test);
    
    return 0;
}
```

2.但是他有一个很大的问题

3.下面的那段代码，会出现异常，为什么呢？因为你要进auto_ptr，的赋值重载，和拷贝构造，让被拷贝的auto_ptr失去对指针的管理权，直接变成nullptr；

```cpp
class Test
{
public:
    Test(void)
    { 
        std::cout << "Test(void)" <<std::endl;
    }
    ~Test(void)
    { 
        std::cout << "~Test(void)" <<std::endl;
    }
};
int main(int argc,char * argv[])
{

    std::auto_ptr<int>  pt1(new int(10));
    std::auto_ptr<int>  pt2(pt1);
    (*pt1)++;
    (*pt2)++;
    return 0;
}
```

4.auto_ptr的实现大概就如下

```c
template<class T>
class auto_ptr
{

public:
    auto_ptr(T * ptr):
    _ptr(ptr)
    { }
    auto_ptr(auto_ptr<T> &  sptr):
    _ptr(sptr._ptr)
    {  
        sptr._ptr = nullptr;

    }
    ~auto_ptr(void)
    { 
        delete _ptr;
    }

    T& operator*(void)
    {
        return *_ptr;
    }
    T* operator->(void)
    {
        return _ptr;
    }


private:
    T * _ptr;
};
```

## 三、unique_ptr 来自C++11

1.确实auto_ptr给🐕，🐕都不用，所以c++11出了一个更好的东西，unique_ptr，他解决了 俩个智能指针共同管理一个对象的情况

2.unique_ptr直接不给你拷贝和赋值

直接就是不给你用了，不给你拷贝了

```c++
class unqiue_ptr
{
    1.方法1
    /* 只声明不实现，当然，有人非得在类外面实现的话，这个就很难受了 */
	unqiue_ptr(const unqiue_ptr & up);
    2.方法2
    /* 我直接搞成私有的，即使你实现了，也不给你用 */
private:
    unqiue_ptr(const unqiue_ptr & up);
	还有赋值的问题 直接operator=不给。
}


```

3.我们来分析一下make_unique 

```cpp
/* unique_ptr用法，除了普通的new,还可以通过make_unique初始化 */
std::unique_ptr<T> t(new T(args...));

/* 下面是make_unique的源码 */
struct _MakeUniq
{ typedef unique_ptr<_Tp> __single_object; }; 

template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }

/* 展开之后你就会发现，make_unique返回的也还是unique_ptr，
	但是拷贝构造已经被禁止了，接受make_unique的时候，走的是右值引用的构造函数
    unique_ptr (unique_ptr&& x) noexcept; */
template<typename _Tp, typename... _Args>
inline  typename unique_ptr<_Tp> make_unique(_Args&&... __args)
 { 
    return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); 
 }

/* 强调一个点！！！make_unique的参数是给new的，也就是用于构造对象的，而不是构造unique_ptr的，他使用new出来的对象去构造unique_ptr的 */
```

## 四、c++还是给你们一个好玩的，可以拷贝的shared_ptr

1.上面的auto_ptr或者是unique_ptr都无法实现俩个智能指针管理同一个对象

```c
Test * pt = new Test;

std::unique_ptr<Test> t3 = std::unique_ptr<Test>(pt);
std::unique_ptr<Test> t4 = std::unique_ptr<Test>(pt);

虽然说能通过这种取巧的方式去实现，但是，在析构的时候会出现pt对象会被析构俩次的情况，所以说本质上还是没有解决这个问题，而且这种写法是不好的，shared_ptr里面也没有搞定这个。所以要么就是std::unique_ptr<Test>(new test),要么就是make_unique不要用这种方式
```

2.为了解决这个问题，shared_ptr

```cpp
std::shared_ptr<Test> sptr1(new Test());
std::shared_ptr<Test> sptr2 = sptr1;

//只会被析构一次，里面有了引用计数。
```

3.讨论一下引用计数的方案

```c
class shared_ptr
{
    
    /* 方案一： 这个肯定不行了。 */
	int _cont;
    /* 方案二：如果新的智能指针指向的是和原来不同的对象是不是也不行 */
    static int _cont;
    /* 方案三：这个就合理起来了， */
    int * p_cont;
};


shared_ptr& operator=(const shared_ptr & t)
{
    if(this->ptr == ps.ptr)
    {
		return *this;
    }
    
    
 	if(this->cont > 1)
    {
    	this->*cont--;
    }
    else if(this->cont == 1 )
    {
		 delete this->cont;
         delete this->ptr;
    }
       
    this->ptr = sp.ptr;
    this->cont = sp.cont;
    
    this->*cont++;
    
    return *this;
        
}


template<class T>
class shared_ptr
{
public:
    shared_ptr(void)
    {

    }
    shared_ptr(T * ptr):
    _ptr(ptr)
    {
        std::cout << " shared_ptr(T * ptr): " << std::endl;
        _cont = new int(1);
    }
    shared_ptr(const shared_ptr<T> & sptr):
    _ptr(sptr._ptr),_cont(sptr._cont)
    {
        (*_cont)++;
        std::cout << " shared_ptr(const shared_ptr<T> & sptr): " << std::endl;
        std::cout << "the cont " << *_cont << std::endl;
    }
    ~shared_ptr(void)
    {
        
        std::cout << " ~shared_ptr(void) " << std::endl;
        std::cout << "the cont " << *_cont << std::endl;
        if(--(*_cont) == 0)
        {
            delete _ptr;
            delete _cont;
            std::cout << "free " << std::endl;
        }
    }

    const shared_ptr<T>& operator=(const shared_ptr<T> & sptr)
    {

        std::cout << "shared_ptr<T> operator=(const shared_ptr<T> & sptr) " << std::endl;
        if(sptr._ptr == this->_ptr)
            return *this;
        if( --(*_cont) == 0)
            delete this->_ptr;
        _ptr = sptr._ptr;
        _cont = sptr._cont;
        (*_cont)++;

        std::cout << "the cont" << *_cont << std::endl;
        return *this;
    }
private:
    T * _ptr;
    int * _cont;
};

template<class T,typename ... Args>
shared_ptr<T> make_sherad(Args ... args)
{
    return shared_ptr<T>(new T(args...));
}
```

## 四、循环引用 weak_ptr

1.这还是just支持shared_ptr，不会增加引用计数。

2.不支持RALL了，不参与shared_ptr的引用计数。

3.可以获取shared_ptr的引用计数

```
struct ListNode
{
	int val;
	yjt::shared_ptr<ListNode> next;
	yjt::shared_ptr<ListNode> prev;
	
}

void test_shared_ptr3()
{
	yjt::shared_ptr<ListNode> n1 = new ListNode;
	yjt::shared_ptr<ListNode> n2 = new ListNode;
	
	n1->next = n2;
	n2->prev = n2;
}
```





## 五、讨论一下，new []的问题

1.在前面我们自己实现的智能指针对于对象都是可以直接delete的，如果是管理对象数组怎么办？肯定是不能直接delete的，所以说就需要一个定制删除器。

```c


std::unique_ptr<Data * > = sp(new Data[10]);

这个的释放只能是delete Data[];

通过的是可调用对象，该对象是对该指针进行删除。
lamba 表达式 
    
也就是定制删除器
无敌的包装器存在！！！！  
    
    
shared_ptr(T * ptr, Delete_t<T> mydele):
_ptr(ptr),_mydel(mydele)
{
    std::cout << " shared_ptr(T * ptr): " << std::endl;
    _cont = new int(1);
}

Delete_t<T> _mydel;
```

## 六、引用计数的线程安全问题

## 七、智能指针的发展历史

98：auto_ptr

boost scoped_ptr + shared_ptr

11：unique_ptr + shared_ptr

