# æ™ºèƒ½æŒ‡é’ˆ



## ä¸€ã€RAII

1.æˆ‘ä»¬æŠŠä¸€ä¸ªèµ„æºé€šè¿‡ä¸€ä¸ªç±»å¸®æˆ‘ä»¬è¿›è¡Œä¿ç®¡ã€‚

2.åœ¨æ„é€ è¿™ä¸ªç±»çš„æ—¶å€™å°±ä¼šå¯¹æˆ‘ä»¬çš„èµ„æºè¿›è¡Œè·å–ï¼Œææ„çš„æ˜¯å°±ä¼šè‡ªåŠ¨çš„é‡Šæ”¾èµ„æº

3.è¿™æ ·æˆ‘ä»¬ä¸ç”¨æ˜¾ç¤ºçš„å»é‡Šæ”¾èµ„æºï¼Œè€Œä¸”èƒ½ä¿è¯å¯¹è±¡æ‰€æœ‰çš„èµ„æºåœ¨ç”Ÿå‘½å‘¨æœŸå†…æœ‰æ•ˆã€‚

### 1-1ï¼šæ™ºèƒ½æŒ‡é’ˆ

1.åœ¨C++98,C++11ä¸­æœ‰æä¾›äº†è¿™äº›ä¸œè¥¿ï¼Œé’ˆå¯¹çš„æ˜¯ç±»

2.æˆ‘ä»¬ç»å¸¸è¦newä¸€ä¸ªå¯¹è±¡å‡ºæ¥ï¼Œä½†æ˜¯å®¹æ˜“å¿˜è®°é‡Šæ”¾è¿™ç§æƒ…å†µï¼Œæ‰€ä»¥è¯´å°±æœ‰äº†æ™ºèƒ½æŒ‡é’ˆï¼Œä½ newå‡ºæ¥çš„å¯¹è±¡ç»™åˆ°æ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥é€šè¿‡åœ¨æ™ºèƒ½æŒ‡é’ˆå¯¹å…¶è¿›è¡Œæ“ä½œï¼Œæ™ºèƒ½æŒ‡é’ˆä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨é‡Šæ”¾

3.RALLç‰¹æ€§

4.åƒæŒ‡é’ˆä¸€æ ·

5.æ‹·è´é—®é¢˜

## äºŒã€auto_ptrç¡®å®æ˜¯æŒ«

### 2-1ï¼šC++98çš„æ™ºèƒ½æŒ‡é’ˆ auto_ptr

1.å¤§æ¦‚çš„ç”¨æ³•å¦‚ä¸‹ï¼šæ¨¡æ¿å‚æ•°å¡«å†™çš„æ˜¯ä½ çš„ç›®æ ‡æŒ‡é’ˆç±»å‹ï¼Œç„¶åé€šè¿‡æ„é€ å‡½æ•°ç»™åˆ°ä¸€ä¸ªæŒ‡é’ˆã€‚

```cpp
class Test
{
public:
    Test(void)
    { 
        std::cout << "Test(void)" <<std::endl;
    }
    ~Test(void)
    { 
        std::cout << "~Test(void)" <<std::endl;
    }
};
int main(int argc,char * argv[])
{
	
    /* æ¨¡æ¿å¡« */ 
    std::auto_ptr<Test>  pt(new Test);
    
    return 0;
}
```

2.ä½†æ˜¯ä»–æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜

3.ä¸‹é¢çš„é‚£æ®µä»£ç ï¼Œä¼šå‡ºç°å¼‚å¸¸ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºä½ è¦è¿›auto_ptrï¼Œçš„èµ‹å€¼é‡è½½ï¼Œå’Œæ‹·è´æ„é€ ï¼Œè®©è¢«æ‹·è´çš„auto_ptrå¤±å»å¯¹æŒ‡é’ˆçš„ç®¡ç†æƒï¼Œç›´æ¥å˜æˆnullptrï¼›

```cpp
class Test
{
public:
    Test(void)
    { 
        std::cout << "Test(void)" <<std::endl;
    }
    ~Test(void)
    { 
        std::cout << "~Test(void)" <<std::endl;
    }
};
int main(int argc,char * argv[])
{

    std::auto_ptr<int>  pt1(new int(10));
    std::auto_ptr<int>  pt2(pt1);
    (*pt1)++;
    (*pt2)++;
    return 0;
}
```

4.auto_ptrçš„å®ç°å¤§æ¦‚å°±å¦‚ä¸‹

```c
template<class T>
class auto_ptr
{

public:
    auto_ptr(T * ptr):
    _ptr(ptr)
    { }
    auto_ptr(auto_ptr<T> &  sptr):
    _ptr(sptr._ptr)
    {  
        sptr._ptr = nullptr;

    }
    ~auto_ptr(void)
    { 
        delete _ptr;
    }

    T& operator*(void)
    {
        return *_ptr;
    }
    T* operator->(void)
    {
        return _ptr;
    }


private:
    T * _ptr;
};
```

## ä¸‰ã€unique_ptr æ¥è‡ªC++11

1.ç¡®å®auto_ptrç»™ğŸ•ï¼ŒğŸ•éƒ½ä¸ç”¨ï¼Œæ‰€ä»¥c++11å‡ºäº†ä¸€ä¸ªæ›´å¥½çš„ä¸œè¥¿ï¼Œunique_ptrï¼Œä»–è§£å†³äº† ä¿©ä¸ªæ™ºèƒ½æŒ‡é’ˆå…±åŒç®¡ç†ä¸€ä¸ªå¯¹è±¡çš„æƒ…å†µ

2.unique_ptrç›´æ¥ä¸ç»™ä½ æ‹·è´å’Œèµ‹å€¼

ç›´æ¥å°±æ˜¯ä¸ç»™ä½ ç”¨äº†ï¼Œä¸ç»™ä½ æ‹·è´äº†

```c++
class unqiue_ptr
{
    1.æ–¹æ³•1
    /* åªå£°æ˜ä¸å®ç°ï¼Œå½“ç„¶ï¼Œæœ‰äººéå¾—åœ¨ç±»å¤–é¢å®ç°çš„è¯ï¼Œè¿™ä¸ªå°±å¾ˆéš¾å—äº† */
	unqiue_ptr(const unqiue_ptr & up);
    2.æ–¹æ³•2
    /* æˆ‘ç›´æ¥ææˆç§æœ‰çš„ï¼Œå³ä½¿ä½ å®ç°äº†ï¼Œä¹Ÿä¸ç»™ä½ ç”¨ */
private:
    unqiue_ptr(const unqiue_ptr & up);
	è¿˜æœ‰èµ‹å€¼çš„é—®é¢˜ ç›´æ¥operator=ä¸ç»™ã€‚
}


```

3.æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹make_unique 

```cpp
/* unique_ptrç”¨æ³•ï¼Œé™¤äº†æ™®é€šçš„new,è¿˜å¯ä»¥é€šè¿‡make_uniqueåˆå§‹åŒ– */
std::unique_ptr<T> t(new T(args...));

/* ä¸‹é¢æ˜¯make_uniqueçš„æºç  */
struct _MakeUniq
{ typedef unique_ptr<_Tp> __single_object; }; 

template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }

/* å±•å¼€ä¹‹åä½ å°±ä¼šå‘ç°ï¼Œmake_uniqueè¿”å›çš„ä¹Ÿè¿˜æ˜¯unique_ptrï¼Œ
	ä½†æ˜¯æ‹·è´æ„é€ å·²ç»è¢«ç¦æ­¢äº†ï¼Œæ¥å—make_uniqueçš„æ—¶å€™ï¼Œèµ°çš„æ˜¯å³å€¼å¼•ç”¨çš„æ„é€ å‡½æ•°
    unique_ptr (unique_ptr&& x) noexcept; */
template<typename _Tp, typename... _Args>
inline  typename unique_ptr<_Tp> make_unique(_Args&&... __args)
 { 
    return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); 
 }

/* å¼ºè°ƒä¸€ä¸ªç‚¹ï¼ï¼ï¼make_uniqueçš„å‚æ•°æ˜¯ç»™newçš„ï¼Œä¹Ÿå°±æ˜¯ç”¨äºæ„é€ å¯¹è±¡çš„ï¼Œè€Œä¸æ˜¯æ„é€ unique_ptrçš„ï¼Œä»–ä½¿ç”¨newå‡ºæ¥çš„å¯¹è±¡å»æ„é€ unique_ptrçš„ */
```

## å››ã€c++è¿˜æ˜¯ç»™ä½ ä»¬ä¸€ä¸ªå¥½ç©çš„ï¼Œå¯ä»¥æ‹·è´çš„shared_ptr

1.ä¸Šé¢çš„auto_ptræˆ–è€…æ˜¯unique_ptréƒ½æ— æ³•å®ç°ä¿©ä¸ªæ™ºèƒ½æŒ‡é’ˆç®¡ç†åŒä¸€ä¸ªå¯¹è±¡

```c
Test * pt = new Test;

std::unique_ptr<Test> t3 = std::unique_ptr<Test>(pt);
std::unique_ptr<Test> t4 = std::unique_ptr<Test>(pt);

è™½ç„¶è¯´èƒ½é€šè¿‡è¿™ç§å–å·§çš„æ–¹å¼å»å®ç°ï¼Œä½†æ˜¯ï¼Œåœ¨ææ„çš„æ—¶å€™ä¼šå‡ºç°ptå¯¹è±¡ä¼šè¢«ææ„ä¿©æ¬¡çš„æƒ…å†µï¼Œæ‰€ä»¥è¯´æœ¬è´¨ä¸Šè¿˜æ˜¯æ²¡æœ‰è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè€Œä¸”è¿™ç§å†™æ³•æ˜¯ä¸å¥½çš„ï¼Œshared_ptré‡Œé¢ä¹Ÿæ²¡æœ‰æå®šè¿™ä¸ªã€‚æ‰€ä»¥è¦ä¹ˆå°±æ˜¯std::unique_ptr<Test>(new test),è¦ä¹ˆå°±æ˜¯make_uniqueä¸è¦ç”¨è¿™ç§æ–¹å¼
```

2.ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œshared_ptr

```cpp
std::shared_ptr<Test> sptr1(new Test());
std::shared_ptr<Test> sptr2 = sptr1;

//åªä¼šè¢«ææ„ä¸€æ¬¡ï¼Œé‡Œé¢æœ‰äº†å¼•ç”¨è®¡æ•°ã€‚
```

3.è®¨è®ºä¸€ä¸‹å¼•ç”¨è®¡æ•°çš„æ–¹æ¡ˆ

```c
class shared_ptr
{
    
    /* æ–¹æ¡ˆä¸€ï¼š è¿™ä¸ªè‚¯å®šä¸è¡Œäº†ã€‚ */
	int _cont;
    /* æ–¹æ¡ˆäºŒï¼šå¦‚æœæ–°çš„æ™ºèƒ½æŒ‡é’ˆæŒ‡å‘çš„æ˜¯å’ŒåŸæ¥ä¸åŒçš„å¯¹è±¡æ˜¯ä¸æ˜¯ä¹Ÿä¸è¡Œ */
    static int _cont;
    /* æ–¹æ¡ˆä¸‰ï¼šè¿™ä¸ªå°±åˆç†èµ·æ¥äº†ï¼Œ */
    int * p_cont;
};


shared_ptr& operator=(const shared_ptr & t)
{
    if(this->ptr == ps.ptr)
    {
		return *this;
    }
    
    
 	if(this->cont > 1)
    {
    	this->*cont--;
    }
    else if(this->cont == 1 )
    {
		 delete this->cont;
         delete this->ptr;
    }
       
    this->ptr = sp.ptr;
    this->cont = sp.cont;
    
    this->*cont++;
    
    return *this;
        
}


template<class T>
class shared_ptr
{
public:
    shared_ptr(void)
    {

    }
    shared_ptr(T * ptr):
    _ptr(ptr)
    {
        std::cout << " shared_ptr(T * ptr): " << std::endl;
        _cont = new int(1);
    }
    shared_ptr(const shared_ptr<T> & sptr):
    _ptr(sptr._ptr),_cont(sptr._cont)
    {
        (*_cont)++;
        std::cout << " shared_ptr(const shared_ptr<T> & sptr): " << std::endl;
        std::cout << "the cont " << *_cont << std::endl;
    }
    ~shared_ptr(void)
    {
        
        std::cout << " ~shared_ptr(void) " << std::endl;
        std::cout << "the cont " << *_cont << std::endl;
        if(--(*_cont) == 0)
        {
            delete _ptr;
            delete _cont;
            std::cout << "free " << std::endl;
        }
    }

    const shared_ptr<T>& operator=(const shared_ptr<T> & sptr)
    {

        std::cout << "shared_ptr<T> operator=(const shared_ptr<T> & sptr) " << std::endl;
        if(sptr._ptr == this->_ptr)
            return *this;
        if( --(*_cont) == 0)
            delete this->_ptr;
        _ptr = sptr._ptr;
        _cont = sptr._cont;
        (*_cont)++;

        std::cout << "the cont" << *_cont << std::endl;
        return *this;
    }
private:
    T * _ptr;
    int * _cont;
};

template<class T,typename ... Args>
shared_ptr<T> make_sherad(Args ... args)
{
    return shared_ptr<T>(new T(args...));
}
```

## å››ã€å¾ªç¯å¼•ç”¨ weak_ptr

1.è¿™è¿˜æ˜¯justæ”¯æŒshared_ptrï¼Œä¸ä¼šå¢åŠ å¼•ç”¨è®¡æ•°ã€‚

2.ä¸æ”¯æŒRALLäº†ï¼Œä¸å‚ä¸shared_ptrçš„å¼•ç”¨è®¡æ•°ã€‚

3.å¯ä»¥è·å–shared_ptrçš„å¼•ç”¨è®¡æ•°

```
struct ListNode
{
	int val;
	yjt::shared_ptr<ListNode> next;
	yjt::shared_ptr<ListNode> prev;
	
}

void test_shared_ptr3()
{
	yjt::shared_ptr<ListNode> n1 = new ListNode;
	yjt::shared_ptr<ListNode> n2 = new ListNode;
	
	n1->next = n2;
	n2->prev = n2;
}
```





## äº”ã€è®¨è®ºä¸€ä¸‹ï¼Œnew []çš„é—®é¢˜

1.åœ¨å‰é¢æˆ‘ä»¬è‡ªå·±å®ç°çš„æ™ºèƒ½æŒ‡é’ˆå¯¹äºå¯¹è±¡éƒ½æ˜¯å¯ä»¥ç›´æ¥deleteçš„ï¼Œå¦‚æœæ˜¯ç®¡ç†å¯¹è±¡æ•°ç»„æ€ä¹ˆåŠï¼Ÿè‚¯å®šæ˜¯ä¸èƒ½ç›´æ¥deleteçš„ï¼Œæ‰€ä»¥è¯´å°±éœ€è¦ä¸€ä¸ªå®šåˆ¶åˆ é™¤å™¨ã€‚

```c


std::unique_ptr<Data * > = sp(new Data[10]);

è¿™ä¸ªçš„é‡Šæ”¾åªèƒ½æ˜¯delete Data[];

é€šè¿‡çš„æ˜¯å¯è°ƒç”¨å¯¹è±¡ï¼Œè¯¥å¯¹è±¡æ˜¯å¯¹è¯¥æŒ‡é’ˆè¿›è¡Œåˆ é™¤ã€‚
lamba è¡¨è¾¾å¼ 
    
ä¹Ÿå°±æ˜¯å®šåˆ¶åˆ é™¤å™¨
æ— æ•Œçš„åŒ…è£…å™¨å­˜åœ¨ï¼ï¼ï¼ï¼  
    
    
shared_ptr(T * ptr, Delete_t<T> mydele):
_ptr(ptr),_mydel(mydele)
{
    std::cout << " shared_ptr(T * ptr): " << std::endl;
    _cont = new int(1);
}

Delete_t<T> _mydel;
```

## å…­ã€å¼•ç”¨è®¡æ•°çš„çº¿ç¨‹å®‰å…¨é—®é¢˜

## ä¸ƒã€æ™ºèƒ½æŒ‡é’ˆçš„å‘å±•å†å²

98ï¼šauto_ptr

boost scoped_ptr + shared_ptr

11ï¼šunique_ptr + shared_ptr

