# 哈希

## 一、unordered_map和unordered_set

1.用法几乎是map和set是差不多的。

2.unordered_map，unordered_set 和普通的map，set的性能区别



## 二、哈希表的实现方式

### 2-0：哈希和哈希表的关系

1.哈希是一种算法，通过建立映射关系，提高查找的效率

2.举个例子：假设有一个图书馆，图书馆有很多的书，如果我们要查找书，我们可以把开头为A的书放在一个地方，为B的放在一个地方。也就是建立映射关系。也就是哈希

![image-20231219195022103](pir\image-20231219195022103.png)

3.哈希表：哈希表是对哈希算法的实现，通过数据存储在一个唯一下标内存

### 2-1：直接映射

1.每个数据存储到对于的下标位置，这种方式可以最大化哈希的效率，保证每次查找都是O（1）但是这种方法在数据不集中的情况下就特别销号内存。

![image-20231219195522564](pir\image-20231219195522564.png)

### 2-2：取余映射

1.把数据映射到一个有效的空间内，大小超过内存空间最大下标的值通过取余的方式，映射到内存中去。

![image-20231219200432816](pir\image-20231219200432816.png)

2.假如此时来了一个数据14要怎么办呢？这就是涉及到哈希冲突问题

#### 2-2-1：哈希冲突问题

1..哈希冲突问题：取余映射就会导致一个下标要存储多个值的问题，就比如有内存的10个，有4和14俩个数据，这俩个数据要存储的位置都是下标为4的内存，要解决这个问题我们如下策略：线性探测，二次探测，哈希桶。

#### 2-2-2：线性探查

1.所谓的线性探查就是如果取余后的位置被占用了，那么往下找，找到一个可以插入的地方

![线性探查](pir\线性探查.gif)

#### 2-2-3：实现取余+线性探查的哈希表

1.插入

```c++
bool Hash<K,V,Hf>::Insert(const pair<K,V> & data)
{
    
    if(Find(data.first))
    {
        
        return false;
    }
    /* 需要扩容的情况 */
    if(_n != 0 &&  _n * 10 / _tables.size() == 7)
    {
       
        Hash<K,V> tmp;
        tmp._tables.resize(_tables.size() * 2);
        
        for(size_t i = 0;i < _tables.size();i++)
        {
            /* 把原来表中的有效数据插入的新的表中 */
            if(_tables[i]._s == EXTIS)
            {
                tmp.Insert(_tables[i]._data);
            }
        }
        _tables.swap(tmp._tables);

    }
    Hf fun;
    
    //进行二度映射
    size_t hashi = fun(data.first) % _tables.size();
   
    
    //查找可以插入的下表
    while(_tables[hashi]._s == EXTIS)
    {

        hashi++;
        hashi %= _tables.size();
        
    }
    _tables[hashi]._data = data;
    _tables[hashi]._s = EXTIS;

    _n++;
    
    return true;
}
```

2.查找

```c++
template<class K,class V ,class Hf>
HashData<K,V>* Hash<K,V,Hf>::Find(const K& k)
{
    
    Hf fun;
    size_t hashi = fun(k) % _tables.size();
   	/* 如果我们只有一个空的状态，那么就无法找到因为哈希冲突的数组 */
    while(_tables[hashi]._s != EMPYT)
    {
        if(_tables[hashi]._s == EXTIS && 
            _tables[hashi]._data.first == k)
        {
            return &_tables[hashi];
        }
        hashi++;
        hashi  %= _tables.size();
    }
    
    return nullptr;
}
```

![image-20231220193331926](pir\image-20231220193331926.png)

3.删除

```c++
template<class K,class V,class Hf >
bool Hash<K,V,Hf>::Erase(const K & k)
{
    auto ret = Find(k);
    if(ret == nullptr)
    {
        return false;
    }    

    ret->_s = DELETE;
    _n--;
}
```

4.解决k不为int类型的处理

```c++
template<class K>
struct Hashfunc
{
    size_t operator()(const K & k)
    {
        return (size_t)k;
    }
};
template<>
struct Hashfunc<string>
{
    /* 给到仿函数，进行字符串和整形的转换 */
    size_t operator()(const string & k)
    {
        size_t hashi = 0;
        for(auto & ch : k)
        {
            hashi *= 31;
            hashi += ch;
        }
    }
};
```





## 三、哈希桶的实现

### 3-1：什么是哈希桶

1.之前的存储方式是在每一个下标存储一个数据，现在改成每一个下标存储链表。可以就可以存储多个数据在下标里面， 这样在面对哈希冲突的时候即使同一个映射的地方数值再多也不会影响到其他下标的值

![image-20231220201319669](pir\image-20231220201319669.png)









### 3-2：插入

1.插入的时候，需要扩容的情况





封装+迭代器的实现

### 3-3：关于扩容的时候尽量保持表的大小是一个质数的问题

## 四、位图

1.在面对大量数据，但是只为了确认这个数据是否存在的情况，我们可以选择使用位图

![image-20231222155306634](pir\image-20231222155306634.png)

2.每一个整形有32位，每一位表示一个数字，位0表示数字0，位1表示数字1，以此类推，如果某个数字存在，就把对应的位进行置1；如果不存在就是0。

```c++
using namespace std;

template<size_t N>
class bit_set
{
public:
    bit_set(void)
    {
        _bittables.resize(N/32 + 1,0);
    }
    void set(size_t x);
    void reset(size_t x);
    bool test(size_t x);

private:
    vector<int> _bittables;
};

template<size_t N>
void bit_set<N>::set(size_t x)
{
    size_t i = x/ 32;
    size_t j = x % 32;

    _bittables[i] |= (1 << j);
}

template<size_t N>
void bit_set<N>::reset(size_t x)
{
    size_t i = x/ 32;
    size_t j = x % 32;

    _bittables[i] &= ~(1 << j);    
}
template<size_t N>
bool bit_set<N>::test(size_t x)
{
    size_t i = x/ 32;
    size_t j = x % 32;
    return (_bittables[i] & (1 << j));
}
```

## 五、布隆过滤器

1.位图在面对非整形的数据的时候会力不从心

2.所以我们就需要布隆过滤器

### 5-1：何为布隆过滤器

1.本质是还是位图，只不过位图的映射是根据整形直接映射，但是布隆过滤器要根据其他类型来映射

2.通过把其他类型的数据转化为整形，然后让对应的标志位置为1

3.这样就会纯在冲突的情况

4.所以我们可以通过不同计算i的方式来映射



4.人家只是一个过滤器，也就是说只是拿来做过滤的，实际的数据我们可以在做一个判断



1. 给两个文件，分别有100亿个query，我们只有1G内存，如何找到两个文件交集？分别给出 精确算法和近似算法
2. 如何扩展BloomFilter使得它支持删除元素的操作
