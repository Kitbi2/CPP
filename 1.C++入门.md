# C++入门

## 一、C++关键字

### 1-1：命名空间

#### 1-1-1：基本的概念

1.为了解决命名冲突的问题c++提出了命名空间这个概念，把变量声明在某个特定的空间

```cpp
#include<iostream>
#include<stdlib.h>//这个头文件里面也有rand这个变量这样就会冲突

int rand = 0;

int main()
{

    return 0;
}
```

2.对命名空间的定义和使用

```cpp
/*********************************域运算符访问*************************************************************/

#include<iostream>
#include<stdlib.h>//这个头文件里面也有rand的函数这样就会冲突

namespace my_room
{
	int rand = 0;
}
int main()
{
    //这是一种访问方式,通过位运算符，对于没有作用域的运算符，默认去全局区找
	printf("%d\n",my_room::rand);
    return 0;
}


/**********************************全展开命名空间************************************************************/
#include<iostream>
#include<stdlib.h>//这个头文件里面也有rand的函数这样就会冲突

namespace my_room
{
	int rand = 0;
}
using namespace my_room;//全部展开，这个行为就可以比作把命名空间的变量丢到全局去里面去
int main()
{
    //这是一种访问方式,通过位运算符，对于没有作用域的运算符，默认去全局区找
	printf("%d\n",my_room::rand);
    return 0;
}

/**********************************局部展开************************************************************/
#include<iostream>
#include<stdlib.h>//这个头文件里面也有rand的函数这样就会冲突

namespace my_room
{
	int rand = 0;
}
using my_room::rand;//局部展开，这个行为就可以比作把命名空间的变量丢到全局去里面去
int main()
{
    //这是一种访问方式,通过位运算符，对于没有作用域的运算符，默认去全局区找
	printf("%d\n",my_room::rand);
    return 0;
}


```

 3.对于结构体的使用

```cpp
#include<iostream>
#include<stdlib.h>//这个头文件里面也有rand的函数这样就会冲突

namespace my_room
{
	int rand = 0;
    struct Node
    {
        int add;
    }
}
using namespace my_room;//全部展开，这个行为就可以比作把命名空间的变量丢到全局去里面去
int main()
{
    //这是一种访问方式,通过位运算符，对于没有作用域的运算符，默认去全局区找
	struct my_room::Node node;
    return 0;
}
```

4.对于俩个文件相同的命名空间，编译器会自动合并 

### 1-2：cout和endl



### 1-3：缺省参数

#### 1-3-1：概念

1.给到函数的参数一个默认的值，如果调用函数的时候没有传值的时候，该参数就会是这个默认值

2.有一个缺省参数，后面的参数必须有缺省参数

3.声明和定义不能同时给缺省参数

```cpp
void Func1(int a = 1)
{
    cout << a << endl;
}

/* 被注释掉的代码是不行的，int b是一个缺省参数，所以int c必须也
	是个缺省参数 */
//void Func2(int a，int b = 2,int c)
void Func2(int a = 1，int b = 2,int c = 3)
{
    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
}
int main()
{
    Func(2);
    Func();
    
    return 0;
}
```

3.缺省参数的应用场景

```cpp
//初始化栈
```

### 1-4：函数重载

1.对于同一个函数名字，通过参数的不同实现不同的接口

2.要保证一个宗旨，对于函数的调用只能有一个函数入口

3.参数个数，参数类型，参数顺序

```cpp
int add(int a,int b)
{

}
int add(int a = 10,int b)
{  
    
}
int add(double a,double b)
{

}

int add(int a,double b)
{

}
int add(double a,int b)
{

}
```

#### 1-4-1：重载的原理

1.c++在函数调用的时候跳转是带修饰别名，而不是像c那样直接那函数名进行跳转。

2.即使函数名字一样，但是参数的不同最后去调用/跳转的时候用的别名也是不同的，这样也就实现了函数的重载

### 1-5：引用

1.用给内存遍历取别名，输出型参数

```cpp
#include<iostream>
int swap(int & b,int & a);

int  main()
{
	int a = 0;
	int b = 12;
    
    //引用必须在定义的时候初始化，而且一个引用只能引用一块内存，不能引用另外一个内存
    int &c = a;
	std :: cout << c << std ::endl;
	swap(a,b);//这里我们把a和b传入给swap函数的时候swap的俩个参数为引用，也就是是给int a，int b这俩快内存取一个命名
    return 0;
}

int swap(int & b,int & a)
{
    
}

```

2.引用做返回值，一般用于返回值全局变量或者堆区没被释放的数据，修改返回对象

```cpp
int& Count()
{
    int n = 0;
    n++;
    return n;
}
int main()
{
    /* 不要用引用返回局部变量 */
    int & ret = Count();
    cout << ret << endl;
    cout << ret << endl;
}
```

3.引用和类

```cpp
struct Seqlist
{
    int& at(int i)
    {
        return a[i];
    }
    int a[10];  
};
int main()
{
	Seqlist s1;
    s1.at(0) = 1;
    
}


```

3.引用和常量

```cpp
int main()
{
	const int a = 0;
    const int &b = a;
    /* 下面的代码是对变量a权限的放大（常量到变量）所以不可以 */
    //int &b = a;
    
    int x = 0;
    const int & y = x;
    
    int i = 0;
    double & d = i;
    const double & d = i;
}
```

4.引用和指针的区别 

从底层的角度上来看，引用也是指针。 

![image-20231009145349619](C:\Users\old\AppData\Roaming\Typora\typora-user-images\image-20231009145349619.png)

### 1-6：内联函数

1.主要是为了补宏这个坑

2.#define ADD(x,y)	((x) + (y))

3.用inline去修饰函数，编译器会根据函数的大小和是否递归决定是否对函数进行展开。也就是说，即使用了inline也不定会展开。 

4.内联函数的声明和定义必须在同一个文件里面

**inline**：关键字

```cpp
inline int add(int a,int b)
{
    return a + b;
}

int main()
{
    int a = 10;
    int b = 10;
    
    //会对函数进行展开，提高了效率和节省空间
    int ret = add(a,b);
    
    
}
```

### 1-7：auto

1.auto不能做参数和数组

```cpp
int main()
{
	int a = 0;
    auto b =a;
    auto c = &b;
    auto& d= a;
	
    //获取某个变量的类型
    cout << typeid(b).name() << endl;
}
```

### 1-8：范围for

```cpp
int main()
{
    int arr[] = {1,2,3,4,5};
    for(int i = 0;i < sizeof(arr)/sizeof(int);i++)
    {
        cout << arr[i] << endl;
    }
    
    //依次取数组的数据给e，并且自动迭代 
    for(auto e:arr)
    {
        cout << e << end;
    }
    for(auto& e:arr //这个arr必须的是数组)
    {
        e *= 2;
        cout << e << end;
    }
    return 0;
}
```

### 1-9：nulltr

```cpp
int f(int x)
{

}
int f(int * x)
{

}

int main()
{
	f(NULL);
    f(nullptr);//这个会掉第二个函数
}
```

