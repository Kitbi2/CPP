#  类和对象

## 一、面向过程和面向对象

1. 不多说，这种思想还是多写代码才能有一个比较好的感受



## 二、类的使用

### 2-1：struct被升级成了类

```cpp
struct Stack
{
    void Init()
    {
        
    }
    
    int * a;
}

int main()
{
    struct Stack s1;
    Stack s2 ;
}
```

### 2-2：类的定义

#### 2-2-1：基本的定义

```cpp
class ClassName
{	
    //成员函数
    
    //成员变量
    
}
```

#### 2-2-2：访问权限

1.public类内外皆可访问

2.protected类内可访问，类外不可

3.privatel类内可访问，类外不可，它和protected的区别我们后面再说

4.没有访问限定，默认为private，struct默认为public 

```cpp
class Stack
{
public: 
    int  a;
private:
	int b;
protected:
	int c;
}; 
```

#### 2-2-3：类的实例化

#### 2-2-4：sizeof类的

1.类内函数不会再类内 ，同一个类， 不同的对象调用的类内函数是同一个，所以会直接把类内函数存在到公共代码区，然后调用函数的时候直接查表去调用函数

2.对于没有成员变量的类，c++会分配一个字节的内存，目的是为了占位，用于表示这个对象是存在的。

#### 2-2-5：this指针

1.由于类的函数是同一个接口，但是内类函数访问成员变量的时候就需要一个指针，指向调用该函数的对象。

2.在形参的时候是不能把this显示写出来，但是可以在类内进行使用，需要知道的是this是一个const在*好右边的指针 

```cpp
class Person
{
    //这里应该是有一个this指针int Init(Person * this,int _a,int _b,int _c)
    int Init(int _a,int _b,int _c)
    {
        this->a = _a;
    }
    
	int  a;

	int b;

	int c;
}
```

**封装**：c++的方法和数据是绑定的。

## 三、构造和析构函数

### 3-1：构造函数

1.类自带的函数，用于初始化成员变量

2.名字和类名同名

3.无返回值

4.可以重载，生成对象时自动调用

5.写了有参构造函数编译器不会提供默认构造函数，提供了拷贝构造函数不会提供默认构造函数和有参构造函数

6.对于内存类型不会进行处理，后来在c++的时候支持在声明的时候使用缺省值，默认构造是指不需要参数就可以调用的构造函数。缺省，编译器生成，我们编写无参数的构造函数

```cpp
#include <stdio.h>
#include <iostream>
class Date 
{
public: 
	
    /*
    	1.对于构造函数的设计最好是全缺省，然后根据自己的需求取设计
    	2.对于成员变量都是自定义类型的类我们可以不写构造函数，直接使用默认构造函数
    */
	Date(int _day = 1,int _mouth = 1,int _year = 1)
	{
		std ::cout << "Date(int day,int mouth,int year)" << std::endl;
		day = _day;
		mouth = _mouth;
		year = _year;
	}	
	void Print(void)
	{
		std::cout << day <<' ' ;
		std::cout << mouth << ' ';
		std::cout << year << std::endl;
	}
private:
	int day;
	int mouth;
	int year;

}; 

int main()
{
	Date D1;
	D1.Print();
  
	Date D2(12,12,2023);
	D2.Print();  	
  return 0;
}

```

### 3-2：析构函数

1.在对象被销毁的时候用于释放在堆区的资源等等

2.我们没有编写会有一个默认的析构函数，没有参数和没有返回值，不可重载

3.后定义的写析构

4.默认的析构函数会调用自定义类型的析构函数 

### 3-3：拷贝构造函数

1.调用的时机：值传参会调用

2.如果没有显示定义，编译器会默认生成默认拷贝构造函数（会进行浅拷贝）

####   3-3-1：浅拷贝和深拷贝

1.默认的拷贝构造函数是浅拷贝，对类内的对象直接进行赋值。这种会导致对象销毁的时候对堆区的内容释放俩次

```c++
class test
{
	/* 拷贝构造的参数是同类型的引用 */
	test(const test & t1)
    {

    }
};
```

## 四、运算符重载

### 4-1：基本概念

1.为了代码的可读性c++引入了重载

```cpp
/* 假如我们要把俩个对象相加的结果复制给另外一个对象 */
class Date
{
public:
    /* 这是对+=进行重载 */
const Date& operator+(int _day)
{
    Date ret = *this;
    ret.day += _day;
    while(ret.day > GetDay(ret.year,ret.mouth))
    {
        ret.day -= GetDay(ret.year,ret.mouth);
        ++ret.mouth;
        if(mouth == 13)
        {
            ret.mouth = 1;
            ret.year++;
        }
    }
    return ret;
}
private:
    int year;
    int mouth;
    int day;
};
/* 这种写法就很low */
const Date& ADD(Date& targ1,Date& targ2)
{
	Date ret;
    ret.year = targ.year + targ2.year;
    ret.day = targ.day + targ2.day;
    ret.year = targ.mouth + targ2.mouth;
    return ret;
}


int main()
{
	Date d1(2023,7,8);
    Date d2(2023,7,8);
    
    /* 有了前面的重载我们就可以直接调用+ */
    Date d3 = d1+d2;
	
    /* 如果没有我们就只能像c那样进行函数调用 */
	Date d3 = ADD(d1,d2);
}
```

2.重载的基本语法

```cpp
返回值 operator重载的符号(参数)
    
实例:
class Date
{
public:
    /* 由于这个是类内成员函数，有一个this指针，
    所以满足了至少有一个非内置类型的条件，而且不用显示的声明 */
const Date& operator+(int _day);
private:
    int year;
    int mouth;
    int day;
};
const Date& Date::operator+(int _day)
{
    Date ret = *this;
    ret.day += _day;
    while(ret.day > GetDay(ret.year,ret.mouth))
    {
        ret.day -= GetDay(ret.year,ret.mouth);
        ++ret.mouth;
        if(mouth == 13)
        {
            ret.mouth = 1;
            ret.year++;
        }
    }
    return ret;
}
1.我们不能重载没有的符号，比如@
2.重载至少有一个非内置类型
3.对于内置类型操作，重载后不会改变
4.sizeof :: ?:  *. .这5个不能进行重载
```

## 五、const对象

1.对于const修饰的对象，我们只能调用const修饰的成员

2.在成员函数要使用成员变量的时候要加上const进行对this指针的修饰

```cpp
class Date
{
public:
    /* 由于这个是类内成员函数，有一个this指针，
    所以满足了至少有一个非内置类型的条件，而且不用显示的声明 */
const Date& operator+(int _day);
      
   	  void Prin(void) const;
      //如果没有const是无法调用的
      void Prin() /*const*/;
private:
    int year;
    int mouth;
    int day;
};
const Date& Date::operator+(int _day)
{
    Date ret = *this;
    ret.day += _day;
    while(ret.day > GetDay(ret.year,ret.mouth))
    {
        ret.day -= GetDay(ret.year,ret.mouth);
        ++ret.mouth;
        if(mouth == 13)
        {
            ret.mouth = 1;
            ret.year++;
        }
    }
    return ret;
}
//这里const是对this进行修饰
void Prin(void) const
{
	cout << "hello world" << endl;
}
int main()
{
    const Date d1;
    d1.Print();
}
```

## 六、初始化列表

### 6-1：语法

```cpp
基本的语法:
返回值 函数名(参数):,,

实例：
class Date
{
public:
    
	Date(int _year,int _mouth,int _day):year(_yeaar),mouth(_mouth),day(_day)
	{

	}
private:
    int year;
    int mouth;
    int day;
}

```

1.c++规定初始化列表是成员变量定义的地方，这主要针对于const成员和引用，还有就是内置类型没有提供默认构造函数的时候或者想自己控制内置类型的初始化

2.即使初始化列表没有某个变量，但是依旧会在初始化列表进行定义，只不过初始化是随机值 

3.成员变量的缺省值是在初始化列表的时候进行初始化，如果显示给了就不用缺省值。初始化的顺 序和声明的顺序有关  

4.针对于要进行堆区开辟空间的时候可能需要检查，所以就需要函数。

5.这个写在定义

### 6-2：explicit关键字

1.构造函数不仅可以构造对象，**对于单个参数或者除第一个参数无默认值其余均有默认值 的构造函数，还具有类型转换的作用。**

```cpp
class other
{
public:
    //当这里的注释去掉的时候explicit进行对函数的修饰的使用就不能使用隐式类型转化
    /*explicit*/other(int a  = 1);
    other(int a  = 1,int b = 1);
    other(const other& a);
private:
    int a;
};

other::other(int a)
{
    std::cout << "other(int a)" << std::endl;
}
other::other(int a,int b)
{
	std::cout << "other(int a,int b)" << std::endl;
}
other::other(const other& a)
{
    std::cout << "other(const other& a)" << std::endl;
}
void test3(void)
{
    //这里10会直接去调用构造函数other(int a)，因为编译器做了优化，所以不会拷贝临时对象
    other o1 = 10;
    
    //这里10会直接去调用构造函数other(int a,intb)，这里是多参数的隐式转化，因为编译器做了优化，所以不会拷贝临时对象
    other o1 = {10,10};

}
int main()
{
    test3();
    return 0;
}
```

## 七、静态成员

1.假定与我们需要统计一个类有多少个对象。和正在使用的这个类有多少个 

2.static成员不能给缺省值，定义在类外进行定义

3.此时静态成员是属于整个类。

```cpp
class other
{
public:
    static int staic_a;
    other(int a = 1);
    other(int a ,int b );
    other(const other& a);

    void vists_staic(void);
private:
    int a;

    
};
void other::vists_staic(void)
{
    //类内对静态成员进行访问
    std::cout << staic_a << std::endl;
}

//在类外进行对静态成员变量的定义
int other:: staic_a = 1;
void test3(void)
{
    //static的成员变量位于静态区,即使没有实例化对象,也能访问
    std::cout << other::staic_a << endl;
    
    other o1;
    o1.vists_staic();
}
int main()
{

    test3();
    return 0;
}
```

4.静态成员函数this指针，不能访问类内成员变量

```cpp
class other
{
public:
    static int static_a;
    
   	other(int a  = 1);
    other(int a ,int b );
    other(const other& a);
    
    void vists_static(void);

    static void static_funtion(void);
private:
    int a;
    
};


void other::static_funtion(void)
{
    //这里是一个静态函数,不能访问内类成员
    //std::cout << a << std::endl;
}
```

## 八、友元函数和友元类

1.在某个函数或者类中，需要进行对某个类私有成员的访问，这是我们就可以定义为友元

### 8-1：友元函数

1.友元函数可访问类的私有和保护成员，

2.但不是类的成员函数 友元函数不能用const修饰 友元函数可以在类定义的任何地方声明

3.不受类访问限定符限制 一个函数可以是多个类

4.的友元函数 友元函数的调用与普通函数的调用原理相同

```cpp

class other
{
    //如果把这一行注释掉，下面的函数就编译不过
    friend void OtherFriendFuntion(void);
public:
    static int static_a;
	other(int a  = 1);
    other(int a ,int b );
    other(const other& a);
    
    void vists_static(void);

    static void static_funtion(void);
private:
    int a;
    //即使你声明在这里也是可以的，友元不受访问限定符的限制
    //friend void OtherFriendFuntion(void);
};

void OtherFriendFuntion(void);

void OtherFriendFuntion(void)
{
    other o1;
    std::cout << o1.a << std::endl;
}
```

### 8-2：友元类

1.友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。

2.友元关系是单向的，不具有交换性。 比如上述Time类和Date类，在Time类中声明Date类为其友元类，那么可以在Date类中直接 访问Time类的私有成员变量，但想在Time类中访问Date类中私有的成员变量则不行。

3.友元关系不能传递 如果C是B的友元， B是A的友元，则不能说明C时A的友元。

4.友元关系不能继承，在继承位置再给大家详细介绍。

```cpp
class otherFrined;


class other
{
    friend void OtherFriendFuntion(void);
    //这里把otherFrined定义为other的友元，所以就可以直接访问other的私有成员
    friend otherFrined;
public:
    static int static_a;
	other(int a  = 1);
    other(int a ,int b );
    other(const other& a) ;
    
    void visits_static(void);

    static void static_funtion(void);
private:
    int a;
    
};

void OtherFriendFuntion(void);

class otherFrined
{
public:
    void visits_other(void);
};

void otherFrined::visits_other(void)
{
    other o1;
    std::cout << o1.a << std::endl;
}
```



## 十一、内部类



概念：如果一个类定义在另一个类的内部，这个内部类就叫做内部类。内部类是一个独立的类， 它不属于外部类，更不能通过外部类的对象去访问内部类的成员。外部类对内部类没有任何优越 的访问权限。 注意：内部类就是外部类的友元类，参见友元类的定义，内部类可以通过外部类的对象参数来访 问外部类中的所有成员。但是外部类不是内部类的友元。 特性： 1. 内部类可以定义在外部类的public、protected、private都是可以的。 2. 注意内部类可以直接访问外部类中的static成员，不需要外部类的对象/类名。 3. sizeof(外部类)=外部类，和内部类没有任何关系。

```cpp
class otherFrined;


class other
{
       
public:
    class other_other
    {
    public:
        other_other(void)
        {
            //直接对other的静态成员进行访问
            static_a++;
        }
    };
    static int static_a;
    other(int a  = 1);
    other(int a ,int b );
    other(const other& a) ;
    
    void visits_static(void);
    void other_other_test(void);
    static void static_funtion(void);
private:
    int a;
    
};
void other::other_other_test(void)
{
    other_other num[10];
    std::cout << static_a << std::endl;
}


```

